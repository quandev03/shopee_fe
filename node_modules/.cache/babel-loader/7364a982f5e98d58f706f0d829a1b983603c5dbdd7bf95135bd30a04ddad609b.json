{"ast":null,"code":"import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\nvar Ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nvar Types = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst treeify = nodes => '▽\\n' + treeifyArray(nodes, thinLines);\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\nfunction treeifyArray(nodes, tpl = heavyLines) {\n  return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n  switch (node.type) {\n    case 'terminal':\n      {\n        const vctr = node.valueContainer;\n        return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n      }\n    case 'tagName':\n      return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n    case 'attrValue':\n      return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n    case 'attrPresence':\n      return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n    case 'pushElement':\n      return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n    case 'popElement':\n      return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n    case 'variant':\n      return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n    case 'matcher':\n      return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\n  }\n}\nfunction prefixItems(tpl, items) {\n  return items.map((item, i, {\n    length\n  }) => prefixItem(tpl, item, i === length - 1)).join('\\n');\n}\nfunction prefixItem(tpl, item, tail = true) {\n  const tpl1 = tpl[tail ? 1 : 0];\n  return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\n}\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  treeify: treeify\n});\nclass DecisionTree {\n  constructor(input) {\n    this.branches = weave(toAstTerminalPairs(input));\n  }\n  build(builder) {\n    return builder(this.branches);\n  }\n}\nfunction toAstTerminalPairs(array) {\n  const len = array.length;\n  const results = new Array(len);\n  for (let i = 0; i < len; i++) {\n    const [selectorString, val] = array[i];\n    const ast = preprocess(parseley.parse1(selectorString));\n    results[i] = {\n      ast: ast,\n      terminal: {\n        type: 'terminal',\n        valueContainer: {\n          index: i,\n          value: val,\n          specificity: ast.specificity\n        }\n      }\n    };\n  }\n  return results;\n}\nfunction preprocess(ast) {\n  reduceSelectorVariants(ast);\n  parseley.normalize(ast);\n  return ast;\n}\nfunction reduceSelectorVariants(ast) {\n  const newList = [];\n  ast.list.forEach(sel => {\n    switch (sel.type) {\n      case 'class':\n        newList.push({\n          matcher: '~=',\n          modifier: null,\n          name: 'class',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n      case 'id':\n        newList.push({\n          matcher: '=',\n          modifier: null,\n          name: 'id',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n      case 'combinator':\n        reduceSelectorVariants(sel.left);\n        newList.push(sel);\n        break;\n      case 'universal':\n        break;\n      default:\n        newList.push(sel);\n        break;\n    }\n  });\n  ast.list = newList;\n}\nfunction weave(items) {\n  const branches = [];\n  while (items.length) {\n    const topKind = findTopKey(items, sel => true, getSelectorKind);\n    const {\n      matches,\n      nonmatches,\n      empty\n    } = breakByKind(items, topKind);\n    items = nonmatches;\n    if (matches.length) {\n      branches.push(branchOfKind(topKind, matches));\n    }\n    if (empty.length) {\n      branches.push(...terminate(empty));\n    }\n  }\n  return branches;\n}\nfunction terminate(items) {\n  const results = [];\n  for (const item of items) {\n    const terminal = item.terminal;\n    if (terminal.type === 'terminal') {\n      results.push(terminal);\n    } else {\n      const {\n        matches,\n        rest\n      } = partition(terminal.cont, node => node.type === 'terminal');\n      matches.forEach(node => results.push(node));\n      if (rest.length) {\n        terminal.cont = rest;\n        results.push(terminal);\n      }\n    }\n  }\n  return results;\n}\nfunction breakByKind(items, selectedKind) {\n  const matches = [];\n  const nonmatches = [];\n  const empty = [];\n  for (const item of items) {\n    const simpsels = item.ast.list;\n    if (simpsels.length) {\n      const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\n      (isMatch ? matches : nonmatches).push(item);\n    } else {\n      empty.push(item);\n    }\n  }\n  return {\n    matches,\n    nonmatches,\n    empty\n  };\n}\nfunction getSelectorKind(sel) {\n  switch (sel.type) {\n    case 'attrPresence':\n      return `attrPresence ${sel.name}`;\n    case 'attrValue':\n      return `attrValue ${sel.name}`;\n    case 'combinator':\n      return `combinator ${sel.combinator}`;\n    default:\n      return sel.type;\n  }\n}\nfunction branchOfKind(kind, items) {\n  if (kind === 'tag') {\n    return tagNameBranch(items);\n  }\n  if (kind.startsWith('attrValue ')) {\n    return attrValueBranch(kind.substring(10), items);\n  }\n  if (kind.startsWith('attrPresence ')) {\n    return attrPresenceBranch(kind.substring(13), items);\n  }\n  if (kind === 'combinator >') {\n    return combinatorBranch('>', items);\n  }\n  if (kind === 'combinator +') {\n    return combinatorBranch('+', items);\n  }\n  throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n  const groups = spliceAndGroup(items, x => x.type === 'tag', x => x.name);\n  const variants = Object.entries(groups).map(([name, group]) => ({\n    type: 'variant',\n    value: name,\n    cont: weave(group.items)\n  }));\n  return {\n    type: 'tagName',\n    variants: variants\n  };\n}\nfunction attrPresenceBranch(name, items) {\n  for (const item of items) {\n    spliceSimpleSelector(item, x => x.type === 'attrPresence' && x.name === name);\n  }\n  return {\n    type: 'attrPresence',\n    name: name,\n    cont: weave(items)\n  };\n}\nfunction attrValueBranch(name, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'attrValue' && x.name === name, x => `${x.matcher} ${x.modifier || ''} ${x.value}`);\n  const matchers = [];\n  for (const group of Object.values(groups)) {\n    const sel = group.oneSimpleSelector;\n    const predicate = getAttrPredicate(sel);\n    const continuation = weave(group.items);\n    matchers.push({\n      type: 'matcher',\n      matcher: sel.matcher,\n      modifier: sel.modifier,\n      value: sel.value,\n      predicate: predicate,\n      cont: continuation\n    });\n  }\n  return {\n    type: 'attrValue',\n    name: name,\n    matchers: matchers\n  };\n}\nfunction getAttrPredicate(sel) {\n  if (sel.modifier === 'i') {\n    const expected = sel.value.toLowerCase();\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual.toLowerCase();\n      case '~=':\n        return actual => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n      case '^=':\n        return actual => actual.toLowerCase().startsWith(expected);\n      case '$=':\n        return actual => actual.toLowerCase().endsWith(expected);\n      case '*=':\n        return actual => actual.toLowerCase().includes(expected);\n      case '|=':\n        return actual => {\n          const lower = actual.toLowerCase();\n          return expected === lower || lower.startsWith(expected) && lower[expected.length] === '-';\n        };\n    }\n  } else {\n    const expected = sel.value;\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual;\n      case '~=':\n        return actual => actual.split(/[ \\t]+/).includes(expected);\n      case '^=':\n        return actual => actual.startsWith(expected);\n      case '$=':\n        return actual => actual.endsWith(expected);\n      case '*=':\n        return actual => actual.includes(expected);\n      case '|=':\n        return actual => expected === actual || actual.startsWith(expected) && actual[expected.length] === '-';\n    }\n  }\n}\nfunction combinatorBranch(combinator, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'combinator' && x.combinator === combinator, x => parseley.serialize(x.left));\n  const leftItems = [];\n  for (const group of Object.values(groups)) {\n    const rightCont = weave(group.items);\n    const leftAst = group.oneSimpleSelector.left;\n    leftItems.push({\n      ast: leftAst,\n      terminal: {\n        type: 'popElement',\n        cont: rightCont\n      }\n    });\n  }\n  return {\n    type: 'pushElement',\n    combinator: combinator,\n    cont: weave(leftItems)\n  };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n  const groups = {};\n  while (items.length) {\n    const bestKey = findTopKey(items, predicate, keyCallback);\n    const bestKeyPredicate = sel => predicate(sel) && keyCallback(sel) === bestKey;\n    const hasBestKeyPredicate = item => item.ast.list.some(bestKeyPredicate);\n    const {\n      matches,\n      rest\n    } = partition1(items, hasBestKeyPredicate);\n    let oneSimpleSelector = null;\n    for (const item of matches) {\n      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n      if (!oneSimpleSelector) {\n        oneSimpleSelector = splicedNode;\n      }\n    }\n    if (oneSimpleSelector == null) {\n      throw new Error('No simple selector is found.');\n    }\n    groups[bestKey] = {\n      oneSimpleSelector: oneSimpleSelector,\n      items: matches\n    };\n    items = rest;\n  }\n  return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n  const simpsels = item.ast.list;\n  const matches = new Array(simpsels.length);\n  let firstIndex = -1;\n  for (let i = simpsels.length; i-- > 0;) {\n    if (predicate(simpsels[i])) {\n      matches[i] = true;\n      firstIndex = i;\n    }\n  }\n  if (firstIndex == -1) {\n    throw new Error(`Couldn't find the required simple selector.`);\n  }\n  const result = simpsels[firstIndex];\n  item.ast.list = simpsels.filter((sel, i) => !matches[i]);\n  return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n  const candidates = {};\n  for (const item of items) {\n    const candidates1 = {};\n    for (const node of item.ast.list.filter(predicate)) {\n      candidates1[keyCallback(node)] = true;\n    }\n    for (const key of Object.keys(candidates1)) {\n      if (candidates[key]) {\n        candidates[key]++;\n      } else {\n        candidates[key] = 1;\n      }\n    }\n  }\n  let topKind = '';\n  let topCounter = 0;\n  for (const entry of Object.entries(candidates)) {\n    if (entry[1] > topCounter) {\n      topKind = entry[0];\n      topCounter = entry[1];\n    }\n  }\n  return topKind;\n}\nfunction partition(src, predicate) {\n  const matches = [];\n  const rest = [];\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n  return {\n    matches,\n    rest\n  };\n}\nfunction partition1(src, predicate) {\n  const matches = [];\n  const rest = [];\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n  return {\n    matches,\n    rest\n  };\n}\nclass Picker {\n  constructor(f) {\n    this.f = f;\n  }\n  pickAll(el) {\n    return this.f(el);\n  }\n  pick1(el, preferFirst = false) {\n    const results = this.f(el);\n    const len = results.length;\n    if (len === 0) {\n      return null;\n    }\n    if (len === 1) {\n      return results[0].value;\n    }\n    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;\n    let result = results[0];\n    for (let i = 1; i < len; i++) {\n      const next = results[i];\n      if (comparator(result, next)) {\n        result = next;\n      }\n    }\n    return result.value;\n  }\n}\nfunction comparatorPreferFirst(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index < acc.index;\n}\nfunction comparatorPreferLast(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index > acc.index;\n}\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };","map":{"version":3,"names":["parseley","compareSpecificity","Ast","Object","freeze","__proto__","Types","treeify","nodes","treeifyArray","thinLines","heavyLines","doubleLines","tpl","prefixItems","map","n","treeifyNode","node","type","vctr","valueContainer","index","JSON","stringify","specificity","value","variants","name","matchers","cont","combinator","matcher","modifier","items","item","i","length","prefixItem","join","tail","tpl1","split","TreeifyBuilder","DecisionTree","constructor","input","branches","weave","toAstTerminalPairs","build","builder","array","len","results","Array","selectorString","val","ast","preprocess","parse1","terminal","reduceSelectorVariants","normalize","newList","list","forEach","sel","push","namespace","left","topKind","findTopKey","getSelectorKind","matches","nonmatches","empty","breakByKind","branchOfKind","terminate","rest","partition","selectedKind","simpsels","isMatch","some","kind","tagNameBranch","startsWith","attrValueBranch","substring","attrPresenceBranch","combinatorBranch","Error","groups","spliceAndGroup","x","entries","group","spliceSimpleSelector","values","oneSimpleSelector","predicate","getAttrPredicate","continuation","expected","toLowerCase","actual","includes","endsWith","lower","serialize","leftItems","rightCont","leftAst","keyCallback","bestKey","bestKeyPredicate","hasBestKeyPredicate","partition1","splicedNode","firstIndex","result","filter","candidates","candidates1","key","keys","topCounter","entry","src","Picker","f","pickAll","el","pick1","preferFirst","comparator","comparatorPreferFirst","comparatorPreferLast","next","acc","diff","Treeify"],"sources":["/Volumes/MAC_Quandev03/Code/JS/Shopee/node_modules/selderee/lib/selderee.mjs"],"sourcesContent":["import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\n\nvar Ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst treeify = (nodes) => '▽\\n' + treeifyArray(nodes, thinLines);\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\nfunction treeifyArray(nodes, tpl = heavyLines) {\n    return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n    switch (node.type) {\n        case 'terminal': {\n            const vctr = node.valueContainer;\n            return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n        }\n        case 'tagName':\n            return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n        case 'attrValue':\n            return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n        case 'attrPresence':\n            return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n        case 'pushElement':\n            return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n        case 'popElement':\n            return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n        case 'variant':\n            return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n        case 'matcher':\n            return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\n    }\n}\nfunction prefixItems(tpl, items) {\n    return items\n        .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))\n        .join('\\n');\n}\nfunction prefixItem(tpl, item, tail = true) {\n    const tpl1 = tpl[tail ? 1 : 0];\n    return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\n}\n\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    treeify: treeify\n});\n\nclass DecisionTree {\n    constructor(input) {\n        this.branches = weave(toAstTerminalPairs(input));\n    }\n    build(builder) {\n        return builder(this.branches);\n    }\n}\nfunction toAstTerminalPairs(array) {\n    const len = array.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n        const [selectorString, val] = array[i];\n        const ast = preprocess(parseley.parse1(selectorString));\n        results[i] = {\n            ast: ast,\n            terminal: {\n                type: 'terminal',\n                valueContainer: { index: i, value: val, specificity: ast.specificity }\n            }\n        };\n    }\n    return results;\n}\nfunction preprocess(ast) {\n    reduceSelectorVariants(ast);\n    parseley.normalize(ast);\n    return ast;\n}\nfunction reduceSelectorVariants(ast) {\n    const newList = [];\n    ast.list.forEach(sel => {\n        switch (sel.type) {\n            case 'class':\n                newList.push({\n                    matcher: '~=',\n                    modifier: null,\n                    name: 'class',\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: 'attrValue',\n                    value: sel.name,\n                });\n                break;\n            case 'id':\n                newList.push({\n                    matcher: '=',\n                    modifier: null,\n                    name: 'id',\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: 'attrValue',\n                    value: sel.name,\n                });\n                break;\n            case 'combinator':\n                reduceSelectorVariants(sel.left);\n                newList.push(sel);\n                break;\n            case 'universal':\n                break;\n            default:\n                newList.push(sel);\n                break;\n        }\n    });\n    ast.list = newList;\n}\nfunction weave(items) {\n    const branches = [];\n    while (items.length) {\n        const topKind = findTopKey(items, (sel) => true, getSelectorKind);\n        const { matches, nonmatches, empty } = breakByKind(items, topKind);\n        items = nonmatches;\n        if (matches.length) {\n            branches.push(branchOfKind(topKind, matches));\n        }\n        if (empty.length) {\n            branches.push(...terminate(empty));\n        }\n    }\n    return branches;\n}\nfunction terminate(items) {\n    const results = [];\n    for (const item of items) {\n        const terminal = item.terminal;\n        if (terminal.type === 'terminal') {\n            results.push(terminal);\n        }\n        else {\n            const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');\n            matches.forEach((node) => results.push(node));\n            if (rest.length) {\n                terminal.cont = rest;\n                results.push(terminal);\n            }\n        }\n    }\n    return results;\n}\nfunction breakByKind(items, selectedKind) {\n    const matches = [];\n    const nonmatches = [];\n    const empty = [];\n    for (const item of items) {\n        const simpsels = item.ast.list;\n        if (simpsels.length) {\n            const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\n            (isMatch ? matches : nonmatches).push(item);\n        }\n        else {\n            empty.push(item);\n        }\n    }\n    return { matches, nonmatches, empty };\n}\nfunction getSelectorKind(sel) {\n    switch (sel.type) {\n        case 'attrPresence':\n            return `attrPresence ${sel.name}`;\n        case 'attrValue':\n            return `attrValue ${sel.name}`;\n        case 'combinator':\n            return `combinator ${sel.combinator}`;\n        default:\n            return sel.type;\n    }\n}\nfunction branchOfKind(kind, items) {\n    if (kind === 'tag') {\n        return tagNameBranch(items);\n    }\n    if (kind.startsWith('attrValue ')) {\n        return attrValueBranch(kind.substring(10), items);\n    }\n    if (kind.startsWith('attrPresence ')) {\n        return attrPresenceBranch(kind.substring(13), items);\n    }\n    if (kind === 'combinator >') {\n        return combinatorBranch('>', items);\n    }\n    if (kind === 'combinator +') {\n        return combinatorBranch('+', items);\n    }\n    throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n    const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);\n    const variants = Object.entries(groups).map(([name, group]) => ({\n        type: 'variant',\n        value: name,\n        cont: weave(group.items)\n    }));\n    return {\n        type: 'tagName',\n        variants: variants\n    };\n}\nfunction attrPresenceBranch(name, items) {\n    for (const item of items) {\n        spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));\n    }\n    return {\n        type: 'attrPresence',\n        name: name,\n        cont: weave(items)\n    };\n}\nfunction attrValueBranch(name, items) {\n    const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);\n    const matchers = [];\n    for (const group of Object.values(groups)) {\n        const sel = group.oneSimpleSelector;\n        const predicate = getAttrPredicate(sel);\n        const continuation = weave(group.items);\n        matchers.push({\n            type: 'matcher',\n            matcher: sel.matcher,\n            modifier: sel.modifier,\n            value: sel.value,\n            predicate: predicate,\n            cont: continuation\n        });\n    }\n    return {\n        type: 'attrValue',\n        name: name,\n        matchers: matchers\n    };\n}\nfunction getAttrPredicate(sel) {\n    if (sel.modifier === 'i') {\n        const expected = sel.value.toLowerCase();\n        switch (sel.matcher) {\n            case '=':\n                return (actual) => expected === actual.toLowerCase();\n            case '~=':\n                return (actual) => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n            case '^=':\n                return (actual) => actual.toLowerCase().startsWith(expected);\n            case '$=':\n                return (actual) => actual.toLowerCase().endsWith(expected);\n            case '*=':\n                return (actual) => actual.toLowerCase().includes(expected);\n            case '|=':\n                return (actual) => {\n                    const lower = actual.toLowerCase();\n                    return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');\n                };\n        }\n    }\n    else {\n        const expected = sel.value;\n        switch (sel.matcher) {\n            case '=':\n                return (actual) => expected === actual;\n            case '~=':\n                return (actual) => actual.split(/[ \\t]+/).includes(expected);\n            case '^=':\n                return (actual) => actual.startsWith(expected);\n            case '$=':\n                return (actual) => actual.endsWith(expected);\n            case '*=':\n                return (actual) => actual.includes(expected);\n            case '|=':\n                return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');\n        }\n    }\n}\nfunction combinatorBranch(combinator, items) {\n    const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => parseley.serialize(x.left));\n    const leftItems = [];\n    for (const group of Object.values(groups)) {\n        const rightCont = weave(group.items);\n        const leftAst = group.oneSimpleSelector.left;\n        leftItems.push({\n            ast: leftAst,\n            terminal: { type: 'popElement', cont: rightCont }\n        });\n    }\n    return {\n        type: 'pushElement',\n        combinator: combinator,\n        cont: weave(leftItems)\n    };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n    const groups = {};\n    while (items.length) {\n        const bestKey = findTopKey(items, predicate, keyCallback);\n        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;\n        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);\n        const { matches, rest } = partition1(items, hasBestKeyPredicate);\n        let oneSimpleSelector = null;\n        for (const item of matches) {\n            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n            if (!oneSimpleSelector) {\n                oneSimpleSelector = splicedNode;\n            }\n        }\n        if (oneSimpleSelector == null) {\n            throw new Error('No simple selector is found.');\n        }\n        groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };\n        items = rest;\n    }\n    return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n    const simpsels = item.ast.list;\n    const matches = new Array(simpsels.length);\n    let firstIndex = -1;\n    for (let i = simpsels.length; i-- > 0;) {\n        if (predicate(simpsels[i])) {\n            matches[i] = true;\n            firstIndex = i;\n        }\n    }\n    if (firstIndex == -1) {\n        throw new Error(`Couldn't find the required simple selector.`);\n    }\n    const result = simpsels[firstIndex];\n    item.ast.list = simpsels.filter((sel, i) => !matches[i]);\n    return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n    const candidates = {};\n    for (const item of items) {\n        const candidates1 = {};\n        for (const node of item.ast.list.filter(predicate)) {\n            candidates1[keyCallback(node)] = true;\n        }\n        for (const key of Object.keys(candidates1)) {\n            if (candidates[key]) {\n                candidates[key]++;\n            }\n            else {\n                candidates[key] = 1;\n            }\n        }\n    }\n    let topKind = '';\n    let topCounter = 0;\n    for (const entry of Object.entries(candidates)) {\n        if (entry[1] > topCounter) {\n            topKind = entry[0];\n            topCounter = entry[1];\n        }\n    }\n    return topKind;\n}\nfunction partition(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src) {\n        if (predicate(x)) {\n            matches.push(x);\n        }\n        else {\n            rest.push(x);\n        }\n    }\n    return { matches, rest };\n}\nfunction partition1(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src) {\n        if (predicate(x)) {\n            matches.push(x);\n        }\n        else {\n            rest.push(x);\n        }\n    }\n    return { matches, rest };\n}\n\nclass Picker {\n    constructor(f) {\n        this.f = f;\n    }\n    pickAll(el) {\n        return this.f(el);\n    }\n    pick1(el, preferFirst = false) {\n        const results = this.f(el);\n        const len = results.length;\n        if (len === 0) {\n            return null;\n        }\n        if (len === 1) {\n            return results[0].value;\n        }\n        const comparator = (preferFirst)\n            ? comparatorPreferFirst\n            : comparatorPreferLast;\n        let result = results[0];\n        for (let i = 1; i < len; i++) {\n            const next = results[i];\n            if (comparator(result, next)) {\n                result = next;\n            }\n        }\n        return result.value;\n    }\n}\nfunction comparatorPreferFirst(acc, next) {\n    const diff = compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || (diff === 0 && next.index < acc.index);\n}\nfunction comparatorPreferLast(acc, next) {\n    const diff = compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || (diff === 0 && next.index > acc.index);\n}\n\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };\n"],"mappings":"AAAA,OAAO,KAAKA,QAAQ,MAAM,UAAU;AACpC,SAASC,kBAAkB,QAAQ,UAAU;AAE7C,IAAIC,GAAG,GAAG,aAAaC,MAAM,CAACC,MAAM,CAAC;EACjCC,SAAS,EAAE;AACf,CAAC,CAAC;AAEF,IAAIC,KAAK,GAAG,aAAaH,MAAM,CAACC,MAAM,CAAC;EACnCC,SAAS,EAAE;AACf,CAAC,CAAC;AAEF,MAAME,OAAO,GAAIC,KAAK,IAAK,KAAK,GAAGC,YAAY,CAACD,KAAK,EAAEE,SAAS,CAAC;AACjE,MAAMA,SAAS,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC9C,MAAMC,UAAU,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC/C,MAAMC,WAAW,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAChD,SAASH,YAAYA,CAACD,KAAK,EAAEK,GAAG,GAAGF,UAAU,EAAE;EAC3C,OAAOG,WAAW,CAACD,GAAG,EAAEL,KAAK,CAACO,GAAG,CAACC,CAAC,IAAIC,WAAW,CAACD,CAAC,CAAC,CAAC,CAAC;AAC3D;AACA,SAASC,WAAWA,CAACC,IAAI,EAAE;EACvB,QAAQA,IAAI,CAACC,IAAI;IACb,KAAK,UAAU;MAAE;QACb,MAAMC,IAAI,GAAGF,IAAI,CAACG,cAAc;QAChC,OAAO,MAAMD,IAAI,CAACE,KAAK,IAAIC,IAAI,CAACC,SAAS,CAACJ,IAAI,CAACK,WAAW,CAAC,IAAIL,IAAI,CAACM,KAAK,EAAE;MAC/E;IACA,KAAK,SAAS;MACV,OAAO,eAAejB,YAAY,CAACS,IAAI,CAACS,QAAQ,EAAEf,WAAW,CAAC,EAAE;IACpE,KAAK,WAAW;MACZ,OAAO,iBAAiBM,IAAI,CAACU,IAAI,KAAKnB,YAAY,CAACS,IAAI,CAACW,QAAQ,EAAEjB,WAAW,CAAC,EAAE;IACpF,KAAK,cAAc;MACf,OAAO,oBAAoBM,IAAI,CAACU,IAAI,KAAKnB,YAAY,CAACS,IAAI,CAACY,IAAI,CAAC,EAAE;IACtE,KAAK,aAAa;MACd,OAAO,mBAAmBZ,IAAI,CAACa,UAAU,KAAKtB,YAAY,CAACS,IAAI,CAACY,IAAI,EAAEpB,SAAS,CAAC,EAAE;IACtF,KAAK,YAAY;MACb,OAAO,kBAAkBD,YAAY,CAACS,IAAI,CAACY,IAAI,EAAEpB,SAAS,CAAC,EAAE;IACjE,KAAK,SAAS;MACV,OAAO,OAAOQ,IAAI,CAACQ,KAAK,KAAKjB,YAAY,CAACS,IAAI,CAACY,IAAI,CAAC,EAAE;IAC1D,KAAK,SAAS;MACV,OAAO,KAAKZ,IAAI,CAACc,OAAO,KAAKd,IAAI,CAACQ,KAAK,IAAIR,IAAI,CAACe,QAAQ,IAAI,EAAE,KAAKxB,YAAY,CAACS,IAAI,CAACY,IAAI,CAAC,EAAE;EACpG;AACJ;AACA,SAAShB,WAAWA,CAACD,GAAG,EAAEqB,KAAK,EAAE;EAC7B,OAAOA,KAAK,CACPnB,GAAG,CAAC,CAACoB,IAAI,EAAEC,CAAC,EAAE;IAAEC;EAAO,CAAC,KAAKC,UAAU,CAACzB,GAAG,EAAEsB,IAAI,EAAEC,CAAC,KAAKC,MAAM,GAAG,CAAC,CAAC,CAAC,CACrEE,IAAI,CAAC,IAAI,CAAC;AACnB;AACA,SAASD,UAAUA,CAACzB,GAAG,EAAEsB,IAAI,EAAEK,IAAI,GAAG,IAAI,EAAE;EACxC,MAAMC,IAAI,GAAG5B,GAAG,CAAC2B,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;EAC9B,OAAOC,IAAI,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACO,KAAK,CAAC,IAAI,CAAC,CAACH,IAAI,CAAC,IAAI,GAAGE,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1D;AAEA,IAAIE,cAAc,GAAG,aAAaxC,MAAM,CAACC,MAAM,CAAC;EAC5CC,SAAS,EAAE,IAAI;EACfE,OAAO,EAAEA;AACb,CAAC,CAAC;AAEF,MAAMqC,YAAY,CAAC;EACfC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAACC,QAAQ,GAAGC,KAAK,CAACC,kBAAkB,CAACH,KAAK,CAAC,CAAC;EACpD;EACAI,KAAKA,CAACC,OAAO,EAAE;IACX,OAAOA,OAAO,CAAC,IAAI,CAACJ,QAAQ,CAAC;EACjC;AACJ;AACA,SAASE,kBAAkBA,CAACG,KAAK,EAAE;EAC/B,MAAMC,GAAG,GAAGD,KAAK,CAACf,MAAM;EACxB,MAAMiB,OAAO,GAAG,IAAIC,KAAK,CAACF,GAAG,CAAC;EAC9B,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,EAAE,EAAE;IAC1B,MAAM,CAACoB,cAAc,EAAEC,GAAG,CAAC,GAAGL,KAAK,CAAChB,CAAC,CAAC;IACtC,MAAMsB,GAAG,GAAGC,UAAU,CAAC3D,QAAQ,CAAC4D,MAAM,CAACJ,cAAc,CAAC,CAAC;IACvDF,OAAO,CAAClB,CAAC,CAAC,GAAG;MACTsB,GAAG,EAAEA,GAAG;MACRG,QAAQ,EAAE;QACN1C,IAAI,EAAE,UAAU;QAChBE,cAAc,EAAE;UAAEC,KAAK,EAAEc,CAAC;UAAEV,KAAK,EAAE+B,GAAG;UAAEhC,WAAW,EAAEiC,GAAG,CAACjC;QAAY;MACzE;IACJ,CAAC;EACL;EACA,OAAO6B,OAAO;AAClB;AACA,SAASK,UAAUA,CAACD,GAAG,EAAE;EACrBI,sBAAsB,CAACJ,GAAG,CAAC;EAC3B1D,QAAQ,CAAC+D,SAAS,CAACL,GAAG,CAAC;EACvB,OAAOA,GAAG;AACd;AACA,SAASI,sBAAsBA,CAACJ,GAAG,EAAE;EACjC,MAAMM,OAAO,GAAG,EAAE;EAClBN,GAAG,CAACO,IAAI,CAACC,OAAO,CAACC,GAAG,IAAI;IACpB,QAAQA,GAAG,CAAChD,IAAI;MACZ,KAAK,OAAO;QACR6C,OAAO,CAACI,IAAI,CAAC;UACTpC,OAAO,EAAE,IAAI;UACbC,QAAQ,EAAE,IAAI;UACdL,IAAI,EAAE,OAAO;UACbyC,SAAS,EAAE,IAAI;UACf5C,WAAW,EAAE0C,GAAG,CAAC1C,WAAW;UAC5BN,IAAI,EAAE,WAAW;UACjBO,KAAK,EAAEyC,GAAG,CAACvC;QACf,CAAC,CAAC;QACF;MACJ,KAAK,IAAI;QACLoC,OAAO,CAACI,IAAI,CAAC;UACTpC,OAAO,EAAE,GAAG;UACZC,QAAQ,EAAE,IAAI;UACdL,IAAI,EAAE,IAAI;UACVyC,SAAS,EAAE,IAAI;UACf5C,WAAW,EAAE0C,GAAG,CAAC1C,WAAW;UAC5BN,IAAI,EAAE,WAAW;UACjBO,KAAK,EAAEyC,GAAG,CAACvC;QACf,CAAC,CAAC;QACF;MACJ,KAAK,YAAY;QACbkC,sBAAsB,CAACK,GAAG,CAACG,IAAI,CAAC;QAChCN,OAAO,CAACI,IAAI,CAACD,GAAG,CAAC;QACjB;MACJ,KAAK,WAAW;QACZ;MACJ;QACIH,OAAO,CAACI,IAAI,CAACD,GAAG,CAAC;QACjB;IACR;EACJ,CAAC,CAAC;EACFT,GAAG,CAACO,IAAI,GAAGD,OAAO;AACtB;AACA,SAAShB,KAAKA,CAACd,KAAK,EAAE;EAClB,MAAMa,QAAQ,GAAG,EAAE;EACnB,OAAOb,KAAK,CAACG,MAAM,EAAE;IACjB,MAAMkC,OAAO,GAAGC,UAAU,CAACtC,KAAK,EAAGiC,GAAG,IAAK,IAAI,EAAEM,eAAe,CAAC;IACjE,MAAM;MAAEC,OAAO;MAAEC,UAAU;MAAEC;IAAM,CAAC,GAAGC,WAAW,CAAC3C,KAAK,EAAEqC,OAAO,CAAC;IAClErC,KAAK,GAAGyC,UAAU;IAClB,IAAID,OAAO,CAACrC,MAAM,EAAE;MAChBU,QAAQ,CAACqB,IAAI,CAACU,YAAY,CAACP,OAAO,EAAEG,OAAO,CAAC,CAAC;IACjD;IACA,IAAIE,KAAK,CAACvC,MAAM,EAAE;MACdU,QAAQ,CAACqB,IAAI,CAAC,GAAGW,SAAS,CAACH,KAAK,CAAC,CAAC;IACtC;EACJ;EACA,OAAO7B,QAAQ;AACnB;AACA,SAASgC,SAASA,CAAC7C,KAAK,EAAE;EACtB,MAAMoB,OAAO,GAAG,EAAE;EAClB,KAAK,MAAMnB,IAAI,IAAID,KAAK,EAAE;IACtB,MAAM2B,QAAQ,GAAG1B,IAAI,CAAC0B,QAAQ;IAC9B,IAAIA,QAAQ,CAAC1C,IAAI,KAAK,UAAU,EAAE;MAC9BmC,OAAO,CAACc,IAAI,CAACP,QAAQ,CAAC;IAC1B,CAAC,MACI;MACD,MAAM;QAAEa,OAAO;QAAEM;MAAK,CAAC,GAAGC,SAAS,CAACpB,QAAQ,CAAC/B,IAAI,EAAGZ,IAAI,IAAKA,IAAI,CAACC,IAAI,KAAK,UAAU,CAAC;MACtFuD,OAAO,CAACR,OAAO,CAAEhD,IAAI,IAAKoC,OAAO,CAACc,IAAI,CAAClD,IAAI,CAAC,CAAC;MAC7C,IAAI8D,IAAI,CAAC3C,MAAM,EAAE;QACbwB,QAAQ,CAAC/B,IAAI,GAAGkD,IAAI;QACpB1B,OAAO,CAACc,IAAI,CAACP,QAAQ,CAAC;MAC1B;IACJ;EACJ;EACA,OAAOP,OAAO;AAClB;AACA,SAASuB,WAAWA,CAAC3C,KAAK,EAAEgD,YAAY,EAAE;EACtC,MAAMR,OAAO,GAAG,EAAE;EAClB,MAAMC,UAAU,GAAG,EAAE;EACrB,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMzC,IAAI,IAAID,KAAK,EAAE;IACtB,MAAMiD,QAAQ,GAAGhD,IAAI,CAACuB,GAAG,CAACO,IAAI;IAC9B,IAAIkB,QAAQ,CAAC9C,MAAM,EAAE;MACjB,MAAM+C,OAAO,GAAGD,QAAQ,CAACE,IAAI,CAACnE,IAAI,IAAIuD,eAAe,CAACvD,IAAI,CAAC,KAAKgE,YAAY,CAAC;MAC7E,CAACE,OAAO,GAAGV,OAAO,GAAGC,UAAU,EAAEP,IAAI,CAACjC,IAAI,CAAC;IAC/C,CAAC,MACI;MACDyC,KAAK,CAACR,IAAI,CAACjC,IAAI,CAAC;IACpB;EACJ;EACA,OAAO;IAAEuC,OAAO;IAAEC,UAAU;IAAEC;EAAM,CAAC;AACzC;AACA,SAASH,eAAeA,CAACN,GAAG,EAAE;EAC1B,QAAQA,GAAG,CAAChD,IAAI;IACZ,KAAK,cAAc;MACf,OAAO,gBAAgBgD,GAAG,CAACvC,IAAI,EAAE;IACrC,KAAK,WAAW;MACZ,OAAO,aAAauC,GAAG,CAACvC,IAAI,EAAE;IAClC,KAAK,YAAY;MACb,OAAO,cAAcuC,GAAG,CAACpC,UAAU,EAAE;IACzC;MACI,OAAOoC,GAAG,CAAChD,IAAI;EACvB;AACJ;AACA,SAAS2D,YAAYA,CAACQ,IAAI,EAAEpD,KAAK,EAAE;EAC/B,IAAIoD,IAAI,KAAK,KAAK,EAAE;IAChB,OAAOC,aAAa,CAACrD,KAAK,CAAC;EAC/B;EACA,IAAIoD,IAAI,CAACE,UAAU,CAAC,YAAY,CAAC,EAAE;IAC/B,OAAOC,eAAe,CAACH,IAAI,CAACI,SAAS,CAAC,EAAE,CAAC,EAAExD,KAAK,CAAC;EACrD;EACA,IAAIoD,IAAI,CAACE,UAAU,CAAC,eAAe,CAAC,EAAE;IAClC,OAAOG,kBAAkB,CAACL,IAAI,CAACI,SAAS,CAAC,EAAE,CAAC,EAAExD,KAAK,CAAC;EACxD;EACA,IAAIoD,IAAI,KAAK,cAAc,EAAE;IACzB,OAAOM,gBAAgB,CAAC,GAAG,EAAE1D,KAAK,CAAC;EACvC;EACA,IAAIoD,IAAI,KAAK,cAAc,EAAE;IACzB,OAAOM,gBAAgB,CAAC,GAAG,EAAE1D,KAAK,CAAC;EACvC;EACA,MAAM,IAAI2D,KAAK,CAAC,8BAA8BP,IAAI,EAAE,CAAC;AACzD;AACA,SAASC,aAAaA,CAACrD,KAAK,EAAE;EAC1B,MAAM4D,MAAM,GAAGC,cAAc,CAAC7D,KAAK,EAAG8D,CAAC,IAAKA,CAAC,CAAC7E,IAAI,KAAK,KAAK,EAAG6E,CAAC,IAAKA,CAAC,CAACpE,IAAI,CAAC;EAC5E,MAAMD,QAAQ,GAAGxB,MAAM,CAAC8F,OAAO,CAACH,MAAM,CAAC,CAAC/E,GAAG,CAAC,CAAC,CAACa,IAAI,EAAEsE,KAAK,CAAC,MAAM;IAC5D/E,IAAI,EAAE,SAAS;IACfO,KAAK,EAAEE,IAAI;IACXE,IAAI,EAAEkB,KAAK,CAACkD,KAAK,CAAChE,KAAK;EAC3B,CAAC,CAAC,CAAC;EACH,OAAO;IACHf,IAAI,EAAE,SAAS;IACfQ,QAAQ,EAAEA;EACd,CAAC;AACL;AACA,SAASgE,kBAAkBA,CAAC/D,IAAI,EAAEM,KAAK,EAAE;EACrC,KAAK,MAAMC,IAAI,IAAID,KAAK,EAAE;IACtBiE,oBAAoB,CAAChE,IAAI,EAAG6D,CAAC,IAAMA,CAAC,CAAC7E,IAAI,KAAK,cAAc,IAAM6E,CAAC,CAACpE,IAAI,KAAKA,IAAK,CAAC;EACvF;EACA,OAAO;IACHT,IAAI,EAAE,cAAc;IACpBS,IAAI,EAAEA,IAAI;IACVE,IAAI,EAAEkB,KAAK,CAACd,KAAK;EACrB,CAAC;AACL;AACA,SAASuD,eAAeA,CAAC7D,IAAI,EAAEM,KAAK,EAAE;EAClC,MAAM4D,MAAM,GAAGC,cAAc,CAAC7D,KAAK,EAAG8D,CAAC,IAAMA,CAAC,CAAC7E,IAAI,KAAK,WAAW,IAAM6E,CAAC,CAACpE,IAAI,KAAKA,IAAK,EAAGoE,CAAC,IAAK,GAAGA,CAAC,CAAChE,OAAO,IAAIgE,CAAC,CAAC/D,QAAQ,IAAI,EAAE,IAAI+D,CAAC,CAACtE,KAAK,EAAE,CAAC;EAChJ,MAAMG,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMqE,KAAK,IAAI/F,MAAM,CAACiG,MAAM,CAACN,MAAM,CAAC,EAAE;IACvC,MAAM3B,GAAG,GAAG+B,KAAK,CAACG,iBAAiB;IACnC,MAAMC,SAAS,GAAGC,gBAAgB,CAACpC,GAAG,CAAC;IACvC,MAAMqC,YAAY,GAAGxD,KAAK,CAACkD,KAAK,CAAChE,KAAK,CAAC;IACvCL,QAAQ,CAACuC,IAAI,CAAC;MACVjD,IAAI,EAAE,SAAS;MACfa,OAAO,EAAEmC,GAAG,CAACnC,OAAO;MACpBC,QAAQ,EAAEkC,GAAG,CAAClC,QAAQ;MACtBP,KAAK,EAAEyC,GAAG,CAACzC,KAAK;MAChB4E,SAAS,EAAEA,SAAS;MACpBxE,IAAI,EAAE0E;IACV,CAAC,CAAC;EACN;EACA,OAAO;IACHrF,IAAI,EAAE,WAAW;IACjBS,IAAI,EAAEA,IAAI;IACVC,QAAQ,EAAEA;EACd,CAAC;AACL;AACA,SAAS0E,gBAAgBA,CAACpC,GAAG,EAAE;EAC3B,IAAIA,GAAG,CAAClC,QAAQ,KAAK,GAAG,EAAE;IACtB,MAAMwE,QAAQ,GAAGtC,GAAG,CAACzC,KAAK,CAACgF,WAAW,CAAC,CAAC;IACxC,QAAQvC,GAAG,CAACnC,OAAO;MACf,KAAK,GAAG;QACJ,OAAQ2E,MAAM,IAAKF,QAAQ,KAAKE,MAAM,CAACD,WAAW,CAAC,CAAC;MACxD,KAAK,IAAI;QACL,OAAQC,MAAM,IAAKA,MAAM,CAACD,WAAW,CAAC,CAAC,CAAChE,KAAK,CAAC,QAAQ,CAAC,CAACkE,QAAQ,CAACH,QAAQ,CAAC;MAC9E,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACD,WAAW,CAAC,CAAC,CAAClB,UAAU,CAACiB,QAAQ,CAAC;MAChE,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACD,WAAW,CAAC,CAAC,CAACG,QAAQ,CAACJ,QAAQ,CAAC;MAC9D,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACD,WAAW,CAAC,CAAC,CAACE,QAAQ,CAACH,QAAQ,CAAC;MAC9D,KAAK,IAAI;QACL,OAAQE,MAAM,IAAK;UACf,MAAMG,KAAK,GAAGH,MAAM,CAACD,WAAW,CAAC,CAAC;UAClC,OAAQD,QAAQ,KAAKK,KAAK,IAAMA,KAAK,CAACtB,UAAU,CAACiB,QAAQ,CAAC,IAAIK,KAAK,CAACL,QAAQ,CAACpE,MAAM,CAAC,KAAK,GAAI;QACjG,CAAC;IACT;EACJ,CAAC,MACI;IACD,MAAMoE,QAAQ,GAAGtC,GAAG,CAACzC,KAAK;IAC1B,QAAQyC,GAAG,CAACnC,OAAO;MACf,KAAK,GAAG;QACJ,OAAQ2E,MAAM,IAAKF,QAAQ,KAAKE,MAAM;MAC1C,KAAK,IAAI;QACL,OAAQA,MAAM,IAAKA,MAAM,CAACjE,KAAK,CAAC,QAAQ,CAAC,CAACkE,QAAQ,CAACH,QAAQ,CAAC;MAChE,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACnB,UAAU,CAACiB,QAAQ,CAAC;MAClD,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACE,QAAQ,CAACJ,QAAQ,CAAC;MAChD,KAAK,IAAI;QACL,OAAQE,MAAM,IAAKA,MAAM,CAACC,QAAQ,CAACH,QAAQ,CAAC;MAChD,KAAK,IAAI;QACL,OAAQE,MAAM,IAAMF,QAAQ,KAAKE,MAAM,IAAMA,MAAM,CAACnB,UAAU,CAACiB,QAAQ,CAAC,IAAIE,MAAM,CAACF,QAAQ,CAACpE,MAAM,CAAC,KAAK,GAAI;IACpH;EACJ;AACJ;AACA,SAASuD,gBAAgBA,CAAC7D,UAAU,EAAEG,KAAK,EAAE;EACzC,MAAM4D,MAAM,GAAGC,cAAc,CAAC7D,KAAK,EAAG8D,CAAC,IAAMA,CAAC,CAAC7E,IAAI,KAAK,YAAY,IAAM6E,CAAC,CAACjE,UAAU,KAAKA,UAAW,EAAGiE,CAAC,IAAKhG,QAAQ,CAAC+G,SAAS,CAACf,CAAC,CAAC1B,IAAI,CAAC,CAAC;EAC1I,MAAM0C,SAAS,GAAG,EAAE;EACpB,KAAK,MAAMd,KAAK,IAAI/F,MAAM,CAACiG,MAAM,CAACN,MAAM,CAAC,EAAE;IACvC,MAAMmB,SAAS,GAAGjE,KAAK,CAACkD,KAAK,CAAChE,KAAK,CAAC;IACpC,MAAMgF,OAAO,GAAGhB,KAAK,CAACG,iBAAiB,CAAC/B,IAAI;IAC5C0C,SAAS,CAAC5C,IAAI,CAAC;MACXV,GAAG,EAAEwD,OAAO;MACZrD,QAAQ,EAAE;QAAE1C,IAAI,EAAE,YAAY;QAAEW,IAAI,EAAEmF;MAAU;IACpD,CAAC,CAAC;EACN;EACA,OAAO;IACH9F,IAAI,EAAE,aAAa;IACnBY,UAAU,EAAEA,UAAU;IACtBD,IAAI,EAAEkB,KAAK,CAACgE,SAAS;EACzB,CAAC;AACL;AACA,SAASjB,cAAcA,CAAC7D,KAAK,EAAEoE,SAAS,EAAEa,WAAW,EAAE;EACnD,MAAMrB,MAAM,GAAG,CAAC,CAAC;EACjB,OAAO5D,KAAK,CAACG,MAAM,EAAE;IACjB,MAAM+E,OAAO,GAAG5C,UAAU,CAACtC,KAAK,EAAEoE,SAAS,EAAEa,WAAW,CAAC;IACzD,MAAME,gBAAgB,GAAIlD,GAAG,IAAKmC,SAAS,CAACnC,GAAG,CAAC,IAAIgD,WAAW,CAAChD,GAAG,CAAC,KAAKiD,OAAO;IAChF,MAAME,mBAAmB,GAAInF,IAAI,IAAKA,IAAI,CAACuB,GAAG,CAACO,IAAI,CAACoB,IAAI,CAACgC,gBAAgB,CAAC;IAC1E,MAAM;MAAE3C,OAAO;MAAEM;IAAK,CAAC,GAAGuC,UAAU,CAACrF,KAAK,EAAEoF,mBAAmB,CAAC;IAChE,IAAIjB,iBAAiB,GAAG,IAAI;IAC5B,KAAK,MAAMlE,IAAI,IAAIuC,OAAO,EAAE;MACxB,MAAM8C,WAAW,GAAGrB,oBAAoB,CAAChE,IAAI,EAAEkF,gBAAgB,CAAC;MAChE,IAAI,CAAChB,iBAAiB,EAAE;QACpBA,iBAAiB,GAAGmB,WAAW;MACnC;IACJ;IACA,IAAInB,iBAAiB,IAAI,IAAI,EAAE;MAC3B,MAAM,IAAIR,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACAC,MAAM,CAACsB,OAAO,CAAC,GAAG;MAAEf,iBAAiB,EAAEA,iBAAiB;MAAEnE,KAAK,EAAEwC;IAAQ,CAAC;IAC1ExC,KAAK,GAAG8C,IAAI;EAChB;EACA,OAAOc,MAAM;AACjB;AACA,SAASK,oBAAoBA,CAAChE,IAAI,EAAEmE,SAAS,EAAE;EAC3C,MAAMnB,QAAQ,GAAGhD,IAAI,CAACuB,GAAG,CAACO,IAAI;EAC9B,MAAMS,OAAO,GAAG,IAAInB,KAAK,CAAC4B,QAAQ,CAAC9C,MAAM,CAAC;EAC1C,IAAIoF,UAAU,GAAG,CAAC,CAAC;EACnB,KAAK,IAAIrF,CAAC,GAAG+C,QAAQ,CAAC9C,MAAM,EAAED,CAAC,EAAE,GAAG,CAAC,GAAG;IACpC,IAAIkE,SAAS,CAACnB,QAAQ,CAAC/C,CAAC,CAAC,CAAC,EAAE;MACxBsC,OAAO,CAACtC,CAAC,CAAC,GAAG,IAAI;MACjBqF,UAAU,GAAGrF,CAAC;IAClB;EACJ;EACA,IAAIqF,UAAU,IAAI,CAAC,CAAC,EAAE;IAClB,MAAM,IAAI5B,KAAK,CAAC,6CAA6C,CAAC;EAClE;EACA,MAAM6B,MAAM,GAAGvC,QAAQ,CAACsC,UAAU,CAAC;EACnCtF,IAAI,CAACuB,GAAG,CAACO,IAAI,GAAGkB,QAAQ,CAACwC,MAAM,CAAC,CAACxD,GAAG,EAAE/B,CAAC,KAAK,CAACsC,OAAO,CAACtC,CAAC,CAAC,CAAC;EACxD,OAAOsF,MAAM;AACjB;AACA,SAASlD,UAAUA,CAACtC,KAAK,EAAEoE,SAAS,EAAEa,WAAW,EAAE;EAC/C,MAAMS,UAAU,GAAG,CAAC,CAAC;EACrB,KAAK,MAAMzF,IAAI,IAAID,KAAK,EAAE;IACtB,MAAM2F,WAAW,GAAG,CAAC,CAAC;IACtB,KAAK,MAAM3G,IAAI,IAAIiB,IAAI,CAACuB,GAAG,CAACO,IAAI,CAAC0D,MAAM,CAACrB,SAAS,CAAC,EAAE;MAChDuB,WAAW,CAACV,WAAW,CAACjG,IAAI,CAAC,CAAC,GAAG,IAAI;IACzC;IACA,KAAK,MAAM4G,GAAG,IAAI3H,MAAM,CAAC4H,IAAI,CAACF,WAAW,CAAC,EAAE;MACxC,IAAID,UAAU,CAACE,GAAG,CAAC,EAAE;QACjBF,UAAU,CAACE,GAAG,CAAC,EAAE;MACrB,CAAC,MACI;QACDF,UAAU,CAACE,GAAG,CAAC,GAAG,CAAC;MACvB;IACJ;EACJ;EACA,IAAIvD,OAAO,GAAG,EAAE;EAChB,IAAIyD,UAAU,GAAG,CAAC;EAClB,KAAK,MAAMC,KAAK,IAAI9H,MAAM,CAAC8F,OAAO,CAAC2B,UAAU,CAAC,EAAE;IAC5C,IAAIK,KAAK,CAAC,CAAC,CAAC,GAAGD,UAAU,EAAE;MACvBzD,OAAO,GAAG0D,KAAK,CAAC,CAAC,CAAC;MAClBD,UAAU,GAAGC,KAAK,CAAC,CAAC,CAAC;IACzB;EACJ;EACA,OAAO1D,OAAO;AAClB;AACA,SAASU,SAASA,CAACiD,GAAG,EAAE5B,SAAS,EAAE;EAC/B,MAAM5B,OAAO,GAAG,EAAE;EAClB,MAAMM,IAAI,GAAG,EAAE;EACf,KAAK,MAAMgB,CAAC,IAAIkC,GAAG,EAAE;IACjB,IAAI5B,SAAS,CAACN,CAAC,CAAC,EAAE;MACdtB,OAAO,CAACN,IAAI,CAAC4B,CAAC,CAAC;IACnB,CAAC,MACI;MACDhB,IAAI,CAACZ,IAAI,CAAC4B,CAAC,CAAC;IAChB;EACJ;EACA,OAAO;IAAEtB,OAAO;IAAEM;EAAK,CAAC;AAC5B;AACA,SAASuC,UAAUA,CAACW,GAAG,EAAE5B,SAAS,EAAE;EAChC,MAAM5B,OAAO,GAAG,EAAE;EAClB,MAAMM,IAAI,GAAG,EAAE;EACf,KAAK,MAAMgB,CAAC,IAAIkC,GAAG,EAAE;IACjB,IAAI5B,SAAS,CAACN,CAAC,CAAC,EAAE;MACdtB,OAAO,CAACN,IAAI,CAAC4B,CAAC,CAAC;IACnB,CAAC,MACI;MACDhB,IAAI,CAACZ,IAAI,CAAC4B,CAAC,CAAC;IAChB;EACJ;EACA,OAAO;IAAEtB,OAAO;IAAEM;EAAK,CAAC;AAC5B;AAEA,MAAMmD,MAAM,CAAC;EACTtF,WAAWA,CAACuF,CAAC,EAAE;IACX,IAAI,CAACA,CAAC,GAAGA,CAAC;EACd;EACAC,OAAOA,CAACC,EAAE,EAAE;IACR,OAAO,IAAI,CAACF,CAAC,CAACE,EAAE,CAAC;EACrB;EACAC,KAAKA,CAACD,EAAE,EAAEE,WAAW,GAAG,KAAK,EAAE;IAC3B,MAAMlF,OAAO,GAAG,IAAI,CAAC8E,CAAC,CAACE,EAAE,CAAC;IAC1B,MAAMjF,GAAG,GAAGC,OAAO,CAACjB,MAAM;IAC1B,IAAIgB,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,IAAI;IACf;IACA,IAAIA,GAAG,KAAK,CAAC,EAAE;MACX,OAAOC,OAAO,CAAC,CAAC,CAAC,CAAC5B,KAAK;IAC3B;IACA,MAAM+G,UAAU,GAAID,WAAW,GACzBE,qBAAqB,GACrBC,oBAAoB;IAC1B,IAAIjB,MAAM,GAAGpE,OAAO,CAAC,CAAC,CAAC;IACvB,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,EAAE,EAAE;MAC1B,MAAMwG,IAAI,GAAGtF,OAAO,CAAClB,CAAC,CAAC;MACvB,IAAIqG,UAAU,CAACf,MAAM,EAAEkB,IAAI,CAAC,EAAE;QAC1BlB,MAAM,GAAGkB,IAAI;MACjB;IACJ;IACA,OAAOlB,MAAM,CAAChG,KAAK;EACvB;AACJ;AACA,SAASgH,qBAAqBA,CAACG,GAAG,EAAED,IAAI,EAAE;EACtC,MAAME,IAAI,GAAG7I,kBAAkB,CAAC2I,IAAI,CAACnH,WAAW,EAAEoH,GAAG,CAACpH,WAAW,CAAC;EAClE,OAAOqH,IAAI,GAAG,CAAC,IAAKA,IAAI,KAAK,CAAC,IAAIF,IAAI,CAACtH,KAAK,GAAGuH,GAAG,CAACvH,KAAM;AAC7D;AACA,SAASqH,oBAAoBA,CAACE,GAAG,EAAED,IAAI,EAAE;EACrC,MAAME,IAAI,GAAG7I,kBAAkB,CAAC2I,IAAI,CAACnH,WAAW,EAAEoH,GAAG,CAACpH,WAAW,CAAC;EAClE,OAAOqH,IAAI,GAAG,CAAC,IAAKA,IAAI,KAAK,CAAC,IAAIF,IAAI,CAACtH,KAAK,GAAGuH,GAAG,CAACvH,KAAM;AAC7D;AAEA,SAASpB,GAAG,EAAE0C,YAAY,EAAEuF,MAAM,EAAExF,cAAc,IAAIoG,OAAO,EAAEzI,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}