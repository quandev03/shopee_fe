{"ast":null,"code":"import axios, { HttpStatusCode } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { clearLS, getAccessTokenFromLS, getRefreshTokenFromLS, setAccessTokenToLS, setProfileToLS, setRefreshTokenToLS } from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nconst mapBackendRolesToFrontend = backendRoles => {\n  const rolesArray = Array.isArray(backendRoles) ? backendRoles : [backendRoles];\n  return rolesArray.map(role => role === 'ROLE_ADMIN' ? 'Admin' : 'User');\n};\nexport class Http {\n  constructor() {\n    this.instance = void 0;\n    this.accessToken = void 0;\n    this.refreshToken = void 0;\n    this.refreshTokenRequest = void 0;\n    this.accessToken = getAccessTokenFromLS();\n    this.refreshToken = getRefreshTokenFromLS();\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5,\n        'expire-refresh-token': 60 * 60\n      }\n    });\n    this.instance.interceptors.request.use(config => {\n      if (this.accessToken && config.headers) {\n        config.headers.Authorization = `Bearer ${this.accessToken}`;\n      }\n      return config;\n    }, error => {\n      return Promise.reject(error);\n    });\n    this.instance.interceptors.response.use(response => {\n      const {\n        url\n      } = response.config;\n      if (url === URL_LOGIN || url === URL_REGISTER) {\n        const result = response.data;\n\n        // Kiểm tra xem API có trả về dữ liệu hợp lệ không\n        if (!result || typeof result !== 'object') {\n          console.error('Invalid API response:', response);\n          return Promise.reject(new Error('Invalid API response'));\n        }\n        const {\n          id,\n          username,\n          accessToken,\n          refreshToken,\n          roles,\n          avatar\n        } = result.data;\n        if (!id || !username || !accessToken || !refreshToken) {\n          console.error('Missing required fields in API response:', result);\n          return Promise.reject(new Error('Incomplete API response'));\n        }\n        this.accessToken = accessToken;\n        this.refreshToken = refreshToken;\n        const formattedRoles = mapBackendRolesToFrontend(roles);\n\n        // Lưu token và profile vào localStorage\n        setAccessTokenToLS(accessToken);\n        setRefreshTokenToLS(refreshToken);\n        setProfileToLS({\n          id,\n          username,\n          roles: formattedRoles,\n          avatar: avatar !== null && avatar !== void 0 ? avatar : undefined\n        });\n      } else if (url === URL_LOGOUT) {\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n      }\n      return response;\n    }, error => {\n      var _error$response;\n      if (![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status)) {\n        var _error$response2;\n        const data = (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data;\n        const message = (data === null || data === void 0 ? void 0 : data.message) || error.message;\n        toast.error(message);\n      }\n      if (isAxiosErrorUnauthorized(error)) {\n        var _error$response3, _error$response4, _error$response4$data;\n        const config = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.config) || {\n          headers: {}\n        };\n        const {\n          url\n        } = config;\n\n        // Nếu token hết hạn và không phải request refresh token, gọi `handleRefreshToken`\n        if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n          this.refreshTokenRequest = this.refreshTokenRequest ? this.refreshTokenRequest : this.handleRefreshToken().then(accessToken => {\n            if (config !== null && config !== void 0 && config.headers) {\n              config.headers.Authorization = `Bearer ${accessToken}`;\n            }\n            return this.instance(config);\n          }).finally(() => {\n            setTimeout(() => {\n              this.refreshTokenRequest = null;\n            }, 3000);\n          });\n          return this.refreshTokenRequest;\n        }\n\n        // Nếu refreshToken cũng hết hạn, đăng xuất\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n        toast.error(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Session expired. Please log in again.');\n      }\n      return Promise.reject(error);\n    });\n  }\n  handleRefreshToken() {\n    return this.instance.post(URL_REFRESH_TOKEN, {\n      refresh_token: this.refreshToken\n    }).then(res => {\n      if (!res.data || !res.data.data || !res.data.data.access_token) {\n        console.error('Invalid refresh token response:', res);\n        return Promise.reject(new Error('Invalid refresh token response'));\n      }\n      const {\n        access_token\n      } = res.data.data;\n      this.accessToken = access_token;\n      setAccessTokenToLS(access_token);\n      return access_token;\n    }).catch(() => {\n      clearLS();\n      this.accessToken = '';\n      this.refreshToken = '';\n      throw new Error();\n    });\n  }\n}\nconst api = new Http().instance;\nexport default api;","map":{"version":3,"names":["axios","HttpStatusCode","toast","config","clearLS","getAccessTokenFromLS","getRefreshTokenFromLS","setAccessTokenToLS","setProfileToLS","setRefreshTokenToLS","URL_LOGIN","URL_LOGOUT","URL_REFRESH_TOKEN","URL_REGISTER","isAxiosErrorUnauthorized","isExpiredTokenError","mapBackendRolesToFrontend","backendRoles","rolesArray","Array","isArray","map","role","Http","constructor","instance","accessToken","refreshToken","refreshTokenRequest","create","baseURL","baseUrl","timeout","headers","interceptors","request","use","Authorization","error","Promise","reject","response","url","result","data","console","Error","id","username","roles","avatar","formattedRoles","undefined","_error$response","UnprocessableEntity","Unauthorized","includes","status","_error$response2","message","_error$response3","_error$response4","_error$response4$data","handleRefreshToken","then","finally","setTimeout","post","refresh_token","res","access_token","catch","api"],"sources":["/Volumes/MAC_Quandev03/Code/JS/Shopee/src/api/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosInstance, HttpStatusCode, InternalAxiosRequestConfig } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { AuthResponses, RefreshTokenResponse } from 'src/@types/auth.type';\nimport {\n  clearLS,\n  getAccessTokenFromLS,\n  getRefreshTokenFromLS,\n  setAccessTokenToLS,\n  setProfileToLS,\n  setRefreshTokenToLS\n} from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nimport { ResponseErrorType } from 'src/@types/utils.type';\n\ntype BackendRole = 'ROLE_ADMIN' | 'ROLE_USER';\ntype Role = 'Admin' | 'User';\nconst mapBackendRolesToFrontend = (backendRoles: BackendRole | BackendRole[]): Role[] => {\n  const rolesArray = Array.isArray(backendRoles) ? backendRoles : [backendRoles];\n  return rolesArray.map(role => role === 'ROLE_ADMIN' ? 'Admin' : 'User');\n};\n\nexport class Http {\n  instance: AxiosInstance;\n  private accessToken: string;\n  private refreshToken: string;\n  private refreshTokenRequest: Promise<any>|null\n  constructor() {\n    this.accessToken = getAccessTokenFromLS();\n    this.refreshToken = getRefreshTokenFromLS();\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5,\n        'expire-refresh-token': 60 * 60\n      }\n    });\n\n    this.instance.interceptors.request.use(\n        (config) => {\n          if (this.accessToken && config.headers) {\n            config.headers.Authorization = `Bearer ${this.accessToken}`;\n          }\n          return config;\n        },\n        (error) => {\n          return Promise.reject(error);\n        }\n    );\n\n    this.instance.interceptors.response.use(\n        (response) => {\n          const { url } = response.config;\n          if (url === URL_LOGIN || url === URL_REGISTER) {\n            const result = response.data as AuthResponses;\n\n            // Kiểm tra xem API có trả về dữ liệu hợp lệ không\n            if (!result || typeof result !== 'object') {\n              console.error('Invalid API response:', response);\n              return Promise.reject(new Error('Invalid API response'));\n            }\n\n            const { id, username, accessToken, refreshToken, roles, avatar } = result.data;\n\n            if (!id || !username || !accessToken || !refreshToken) {\n              console.error('Missing required fields in API response:', result);\n              return Promise.reject(new Error('Incomplete API response'));\n            }\n\n            this.accessToken = accessToken;\n            this.refreshToken = refreshToken;\n            const formattedRoles: Role[] = mapBackendRolesToFrontend(roles);\n\n            // Lưu token và profile vào localStorage\n            setAccessTokenToLS(accessToken);\n            setRefreshTokenToLS(refreshToken);\n            setProfileToLS({ id, username, roles: formattedRoles, avatar: avatar ?? undefined });\n          } else if (url === URL_LOGOUT) {\n            this.accessToken = '';\n            this.refreshToken = '';\n            clearLS();\n          }\n\n          return response;\n        },\n        (error: AxiosError) => {\n          if (![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes(error.response?.status as number)) {\n            const data: any = error.response?.data;\n            const message = data?.message || error.message;\n            toast.error(message);\n          }\n\n          if (isAxiosErrorUnauthorized<ResponseErrorType<{ name: string; message: string }>>(error)) {\n            const config = error.response?.config || ({ headers: {} } as InternalAxiosRequestConfig);\n            const { url } = config;\n\n            // Nếu token hết hạn và không phải request refresh token, gọi `handleRefreshToken`\n            if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n              this.refreshTokenRequest = this.refreshTokenRequest\n                  ? this.refreshTokenRequest\n                  : this.handleRefreshToken()\n                      .then((accessToken) => {\n                        if (config?.headers) {\n                          config.headers.Authorization = `Bearer ${accessToken}`;\n                        }\n                        return this.instance(config);\n                      })\n                      .finally(() => {\n                        setTimeout(() => {\n                          this.refreshTokenRequest = null;\n                        }, 3000);\n                      });\n\n              return this.refreshTokenRequest;\n            }\n\n            // Nếu refreshToken cũng hết hạn, đăng xuất\n            this.accessToken = '';\n            this.refreshToken = '';\n            clearLS();\n            toast.error(error.response?.data?.message || 'Session expired. Please log in again.');\n          }\n\n          return Promise.reject(error);\n        }\n    );\n  }\n\n  private handleRefreshToken() {\n    return this.instance\n        .post<RefreshTokenResponse>(URL_REFRESH_TOKEN, { refresh_token: this.refreshToken })\n        .then((res) => {\n          if (!res.data || !res.data.data || !res.data.data.access_token) {\n            console.error('Invalid refresh token response:', res);\n            return Promise.reject(new Error('Invalid refresh token response'));\n          }\n          const { access_token } = res.data.data;\n          this.accessToken = access_token;\n          setAccessTokenToLS(access_token);\n          return access_token;\n        })\n        .catch(() => {\n          clearLS();\n          this.accessToken = '';\n          this.refreshToken = '';\n          throw new Error();\n        });\n  }\n}\n\nconst api = new Http().instance;\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}