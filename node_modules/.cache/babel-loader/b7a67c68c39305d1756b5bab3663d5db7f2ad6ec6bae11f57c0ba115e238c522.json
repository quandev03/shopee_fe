{"ast":null,"code":"import axios, { HttpStatusCode } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { clearLS, getAccessTokenFromLS, getRefreshTokenFromLS, setAccessTokenToLS, setProfileToLS, setRefreshTokenToLS } from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nconst mapBackendRolesToFrontend = backendRoles => {\n  const rolesArray = Array.isArray(backendRoles) ? backendRoles : [backendRoles];\n  return rolesArray.map(role => role === 'ROLE_ADMIN' ? 'Admin' : 'User');\n};\nexport class Http {\n  constructor() {\n    this.instance = void 0;\n    this.accessToken = void 0;\n    this.refreshToken = void 0;\n    this.refreshTokenRequest = void 0;\n    this.accessToken = getAccessTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshToken = getRefreshTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5,\n        //5 giây\n        'expire-refresh-token': 60 * 60 // 1 giờ\n      }\n    });\n    this.instance.interceptors.request.use(config => {\n      if (this.accessToken && config.headers) {\n        config.headers.Authorization = this.accessToken;\n        /**\n         * Lấy accessToken từ đối thượng HTTP tức là lấy dữ liệu từ RAM\n         * Lấy accessToken từ localStorage tức là lấy dữ liệu từ ROM\n         * ==> lấy từ RAM sẽ cho tốc độ tải dữ liệu nhanh hơn lấy từ ROM\n         */\n      }\n      return config;\n    }, error => {\n      return Promise.reject(error);\n    });\n    this.instance.interceptors.response.use(response => {\n      // console.log(response);\n      const {\n        url\n      } = response.config;\n      if (url === URL_LOGIN || url === URL_REGISTER) {\n        const result = response.data;\n        const {\n          id,\n          username,\n          accessToken,\n          refreshToken,\n          roles,\n          avatar\n        } = result.data;\n        this.accessToken = accessToken;\n        this.refreshToken = refreshToken;\n        const formattedRoles = mapBackendRolesToFrontend(roles);\n        setAccessTokenToLS(accessToken);\n        setRefreshTokenToLS(refreshToken);\n        setProfileToLS({\n          id,\n          username,\n          roles: formattedRoles,\n          avatar: avatar !== null && avatar !== void 0 ? avatar : undefined\n        });\n      } else if (url === URL_LOGOUT) {\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n      }\n      return response;\n    }, error => {\n      var _error$response;\n      //Chỉ toast những lỗi không liên quan 422 và 401\n      if (![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status)) {\n        var _error$response2;\n        const data = (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data;\n        const message = (data === null || data === void 0 ? void 0 : data.message) || error.message;\n        toast.error(message);\n      }\n\n      //Lỗi 401 có nhiều trường hợp\n      // - trường hợp không truyền lên access_token\n      // - trường hợp truyền lên access_token không đúng\n      // - trường hợp refresh_token hết hạn\n      // - trường hợp truyền lên access_token hết hạn ==> tiến hành xử lý refresh_token\n\n      if (isAxiosErrorUnauthorized(error)) {\n        var _error$response3, _error$response4, _error$response4$data, _error$response5;\n        const config = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.config) || {\n          headers: {}\n        };\n        const {\n          url\n        } = config;\n        //Trường hợp token hết hạn và request truyền đi không phải là api gọi refresh token\n        if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n          var _this$handleRefreshTo, _this$refreshTokenReq;\n          this.refreshTokenRequest = this.refreshTokenRequest ? this.refreshTokenRequest : (_this$handleRefreshTo = this.handleRefreshToken()) === null || _this$handleRefreshTo === void 0 ? void 0 : _this$handleRefreshTo.finally(() => {\n            //Giữ refreshToken trong 3s tiếp theo để những request tiếp theo bị 401 thì vẫn dùng requestTokenRequest này\n            //Và số giây giữ phải nhỏ hơn thời gian hết hạn của refreshToken\n            setTimeout(() => {\n              this.refreshTokenRequest = null;\n            }, 3000);\n          });\n          return (_this$refreshTokenReq = this.refreshTokenRequest) === null || _this$refreshTokenReq === void 0 ? void 0 : _this$refreshTokenReq.then(access_token => {\n            if (config !== null && config !== void 0 && config.headers) {\n              //Nghĩa là chúng ta tiếp tục gọi lại request củ vừa bị lỗi\n              return this.instance({\n                ...config,\n                headers: {\n                  ...config.headers,\n                  Authorization: access_token\n                }\n              });\n            }\n          });\n        }\n\n        //Còn những trường hợp như truyền sai token, token hết hạn và refreshToken cũng hết hạn thì toast message\n        // Và xóa toàn bộ token trong http và LS\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n        toast.error(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.data.message));\n      }\n      return Promise.reject(error);\n    });\n  }\n  handleRefreshToken() {\n    return this.instance.post(URL_REFRESH_TOKEN, {\n      refresh_token: this.refreshToken\n    }).then(res => {\n      const {\n        access_token\n      } = res.data.data;\n      this.accessToken = access_token;\n      setAccessTokenToLS(access_token);\n      return access_token;\n    }).catch(() => {\n      clearLS();\n      this.accessToken = '';\n      this.refreshToken = '';\n      throw new Error();\n    });\n  }\n}\nconst api = new Http().instance;\nexport default api;","map":{"version":3,"names":["axios","HttpStatusCode","toast","config","clearLS","getAccessTokenFromLS","getRefreshTokenFromLS","setAccessTokenToLS","setProfileToLS","setRefreshTokenToLS","URL_LOGIN","URL_LOGOUT","URL_REFRESH_TOKEN","URL_REGISTER","isAxiosErrorUnauthorized","isExpiredTokenError","mapBackendRolesToFrontend","backendRoles","rolesArray","Array","isArray","map","role","Http","constructor","instance","accessToken","refreshToken","refreshTokenRequest","create","baseURL","baseUrl","timeout","headers","interceptors","request","use","Authorization","error","Promise","reject","response","url","result","data","id","username","roles","avatar","formattedRoles","undefined","_error$response","UnprocessableEntity","Unauthorized","includes","status","_error$response2","message","_error$response3","_error$response4","_error$response4$data","_error$response5","_this$handleRefreshTo","_this$refreshTokenReq","handleRefreshToken","finally","setTimeout","then","access_token","post","refresh_token","res","catch","Error","api"],"sources":["/Volumes/MAC_Quandev03/Code/JS/Shopee/src/api/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosInstance, HttpStatusCode, InternalAxiosRequestConfig } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { AuthResponses, RefreshTokenResponse } from 'src/@types/auth.type';\nimport {\n  clearLS,\n  getAccessTokenFromLS,\n  getRefreshTokenFromLS,\n  setAccessTokenToLS,\n  setProfileToLS,\n  setRefreshTokenToLS\n} from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nimport { ResponseErrorType } from 'src/@types/utils.type';\n\ntype BackendRole = 'ROLE_ADMIN' | 'ROLE_USER';\ntype Role = 'Admin' | 'User';\nconst mapBackendRolesToFrontend = (backendRoles: BackendRole | BackendRole[]): Role[] => {\n  const rolesArray = Array.isArray(backendRoles) ? backendRoles : [backendRoles];\n  return rolesArray.map(role => role === 'ROLE_ADMIN' ? 'Admin' : 'User');\n};\n\nexport class Http {\n  instance: AxiosInstance;\n  private accessToken: string;\n  private refreshToken: string;\n  private refreshTokenRequest: Promise<string> | null;\n  constructor() {\n    this.accessToken = getAccessTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshToken = getRefreshTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5, //5 giây\n        'expire-refresh-token': 60 * 60 // 1 giờ\n      }\n    });\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        if (this.accessToken && config.headers) {\n          config.headers.Authorization = this.accessToken;\n          /**\n           * Lấy accessToken từ đối thượng HTTP tức là lấy dữ liệu từ RAM\n           * Lấy accessToken từ localStorage tức là lấy dữ liệu từ ROM\n           * ==> lấy từ RAM sẽ cho tốc độ tải dữ liệu nhanh hơn lấy từ ROM\n           */\n        }\n        return config;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n\n    this.instance.interceptors.response.use(\n      (response) => {\n        // console.log(response);\n        const { url } = response.config;\n\n        if (url === URL_LOGIN || url === URL_REGISTER) {\n          const result = response.data as AuthResponses;\n\n          const { id, username, accessToken, refreshToken, roles, avatar } = result.data;\n          this.accessToken = accessToken;\n          this.refreshToken = refreshToken;\n          const formattedRoles: Role[] = mapBackendRolesToFrontend(roles);\n          setAccessTokenToLS(accessToken);\n          setRefreshTokenToLS(refreshToken);\n          setProfileToLS({ id, username, roles: formattedRoles, avatar: avatar ?? undefined });\n        } else if (url === URL_LOGOUT) {\n          this.accessToken = '';\n          this.refreshToken = '';\n          clearLS();\n        }\n\n        return response;\n      },\n      (error: AxiosError) => {\n        //Chỉ toast những lỗi không liên quan 422 và 401\n        if (\n          ![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes(error.response?.status as number)\n        ) {\n          const data: any = error.response?.data;\n          const message = data?.message || error.message;\n          toast.error(message);\n        }\n\n        //Lỗi 401 có nhiều trường hợp\n        // - trường hợp không truyền lên access_token\n        // - trường hợp truyền lên access_token không đúng\n        // - trường hợp refresh_token hết hạn\n        // - trường hợp truyền lên access_token hết hạn ==> tiến hành xử lý refresh_token\n\n        if (isAxiosErrorUnauthorized<ResponseErrorType<{ name: string; message: string }>>(error)) {\n          const config = error.response?.config || ({ headers: {} } as InternalAxiosRequestConfig);\n\n          const { url } = config;\n          //Trường hợp token hết hạn và request truyền đi không phải là api gọi refresh token\n          if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n            this.refreshTokenRequest = this.refreshTokenRequest\n              ? this.refreshTokenRequest\n              : this.handleRefreshToken()?.finally(() => {\n                  //Giữ refreshToken trong 3s tiếp theo để những request tiếp theo bị 401 thì vẫn dùng requestTokenRequest này\n                  //Và số giây giữ phải nhỏ hơn thời gian hết hạn của refreshToken\n                  setTimeout(() => {\n                    this.refreshTokenRequest = null;\n                  }, 3000);\n                });\n\n            return this.refreshTokenRequest?.then((access_token) => {\n              if (config?.headers) {\n                //Nghĩa là chúng ta tiếp tục gọi lại request củ vừa bị lỗi\n                return this.instance({ ...config, headers: { ...config.headers, Authorization: access_token } });\n              }\n            });\n          }\n\n          //Còn những trường hợp như truyền sai token, token hết hạn và refreshToken cũng hết hạn thì toast message\n          // Và xóa toàn bộ token trong http và LS\n          this.accessToken = '';\n          this.refreshToken = '';\n          clearLS();\n          toast.error(error.response?.data.data?.message || error.response?.data.message);\n        }\n\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  private handleRefreshToken() {\n    return this.instance\n      .post<RefreshTokenResponse>(URL_REFRESH_TOKEN, { refresh_token: this.refreshToken })\n      .then((res) => {\n        const { access_token } = res.data.data;\n        this.accessToken = access_token;\n        setAccessTokenToLS(access_token);\n        return access_token;\n      })\n      .catch(() => {\n        clearLS();\n        this.accessToken = '';\n        this.refreshToken = '';\n        throw new Error();\n      });\n  }\n}\n\nconst api = new Http().instance;\n\nexport default api;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}