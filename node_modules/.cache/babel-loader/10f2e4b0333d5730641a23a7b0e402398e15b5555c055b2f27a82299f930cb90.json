{"ast":null,"code":"import axios, { HttpStatusCode } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { clearLS, getAccessTokenFromLS, getRefreshTokenFromLS, setAccessTokenToLS, setProfileToLS, setRefreshTokenToLS } from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nexport class Http {\n  constructor() {\n    this.instance = void 0;\n    this.accessToken = void 0;\n    this.refreshToken = void 0;\n    this.refreshTokenRequest = void 0;\n    this.accessToken = getAccessTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshToken = getRefreshTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5,\n        //5 giây\n        'expire-refresh-token': 60 * 60 // 1 giờ\n      }\n    });\n    this.instance.interceptors.request.use(config => {\n      if (this.accessToken && config.headers) {\n        config.headers.Authorization = this.accessToken;\n        /**\n         * Lấy accessToken từ đối thượng HTTP tức là lấy dữ liệu từ RAM\n         * Lấy accessToken từ localStorage tức là lấy dữ liệu từ ROM\n         * ==> lấy từ RAM sẽ cho tốc độ tải dữ liệu nhanh hơn lấy từ ROM\n         */\n      }\n      return config;\n    }, error => {\n      return Promise.reject(error);\n    });\n    this.instance.interceptors.response.use(response => {\n      // console.log(response);\n      const {\n        url\n      } = response.config;\n      if (url === URL_LOGIN || url === URL_REGISTER) {\n        const result = response.data;\n        const {\n          accessToken,\n          username,\n          refreshToken,\n          avatar,\n          roles\n        } = result.data;\n        this.accessToken = accessToken;\n        this.refreshToken = refreshToken;\n        setAccessTokenToLS(accessToken);\n        setRefreshTokenToLS(refreshToken);\n        setProfileToLS({\n          id,\n          username,\n          roles: formattedRoles,\n          avatar: avatar !== null && avatar !== void 0 ? avatar : undefined\n        });\n      } else if (url === URL_LOGOUT) {\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n      }\n      return response;\n    }, error => {\n      var _error$response;\n      //Chỉ toast những lỗi không liên quan 422 và 401\n      if (![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status)) {\n        var _error$response2;\n        const data = (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data;\n        const message = (data === null || data === void 0 ? void 0 : data.message) || error.message;\n        toast.error(message);\n      }\n\n      //Lỗi 401 có nhiều trường hợp\n      // - trường hợp không truyền lên access_token\n      // - trường hợp truyền lên access_token không đúng\n      // - trường hợp refresh_token hết hạn\n      // - trường hợp truyền lên access_token hết hạn ==> tiến hành xử lý refresh_token\n\n      if (isAxiosErrorUnauthorized(error)) {\n        var _error$response3, _error$response4, _error$response4$data, _error$response5;\n        const config = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.config) || {\n          headers: {}\n        };\n        const {\n          url\n        } = config;\n        //Trường hợp token hết hạn và request truyền đi không phải là api gọi refresh token\n        if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n          var _this$handleRefreshTo, _this$refreshTokenReq;\n          this.refreshTokenRequest = this.refreshTokenRequest ? this.refreshTokenRequest : (_this$handleRefreshTo = this.handleRefreshToken()) === null || _this$handleRefreshTo === void 0 ? void 0 : _this$handleRefreshTo.finally(() => {\n            //Giữ refreshToken trong 3s tiếp theo để những request tiếp theo bị 401 thì vẫn dùng requestTokenRequest này\n            //Và số giây giữ phải nhỏ hơn thời gian hết hạn của refreshToken\n            setTimeout(() => {\n              this.refreshTokenRequest = null;\n            }, 3000);\n          });\n          return (_this$refreshTokenReq = this.refreshTokenRequest) === null || _this$refreshTokenReq === void 0 ? void 0 : _this$refreshTokenReq.then(access_token => {\n            if (config !== null && config !== void 0 && config.headers) {\n              //Nghĩa là chúng ta tiếp tục gọi lại request củ vừa bị lỗi\n              return this.instance({\n                ...config,\n                headers: {\n                  ...config.headers,\n                  Authorization: access_token\n                }\n              });\n            }\n          });\n        }\n\n        //Còn những trường hợp như truyền sai token, token hết hạn và refreshToken cũng hết hạn thì toast message\n        // Và xóa toàn bộ token trong http và LS\n        this.accessToken = '';\n        this.refreshToken = '';\n        clearLS();\n        toast.error(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.data.message));\n      }\n      return Promise.reject(error);\n    });\n  }\n  handleRefreshToken() {\n    return this.instance.post(URL_REFRESH_TOKEN, {\n      refresh_token: this.refreshToken\n    }).then(res => {\n      const {\n        access_token\n      } = res.data.data;\n      this.accessToken = access_token;\n      setAccessTokenToLS(access_token);\n      return access_token;\n    }).catch(() => {\n      clearLS();\n      this.accessToken = '';\n      this.refreshToken = '';\n      throw new Error();\n    });\n  }\n}\nconst api = new Http().instance;\nexport default api;","map":{"version":3,"names":["axios","HttpStatusCode","toast","config","clearLS","getAccessTokenFromLS","getRefreshTokenFromLS","setAccessTokenToLS","setProfileToLS","setRefreshTokenToLS","URL_LOGIN","URL_LOGOUT","URL_REFRESH_TOKEN","URL_REGISTER","isAxiosErrorUnauthorized","isExpiredTokenError","Http","constructor","instance","accessToken","refreshToken","refreshTokenRequest","create","baseURL","baseUrl","timeout","headers","interceptors","request","use","Authorization","error","Promise","reject","response","url","result","data","username","avatar","roles","id","formattedRoles","undefined","_error$response","UnprocessableEntity","Unauthorized","includes","status","_error$response2","message","_error$response3","_error$response4","_error$response4$data","_error$response5","_this$handleRefreshTo","_this$refreshTokenReq","handleRefreshToken","finally","setTimeout","then","access_token","post","refresh_token","res","catch","Error","api"],"sources":["/Volumes/MAC_Quandev03/Code/JS/Shopee/src/api/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosInstance, HttpStatusCode, InternalAxiosRequestConfig } from 'axios';\nimport { toast } from 'react-toastify';\nimport config from 'src/constants/config';\nimport { AuthResponse, RefreshTokenResponse } from 'src/@types/auth.type';\nimport {\n  clearLS,\n  getAccessTokenFromLS,\n  getRefreshTokenFromLS,\n  setAccessTokenToLS,\n  setProfileToLS,\n  setRefreshTokenToLS\n} from 'src/utils/auth';\nimport { URL_LOGIN, URL_LOGOUT, URL_REFRESH_TOKEN, URL_REGISTER } from './auth.api';\nimport { isAxiosErrorUnauthorized, isExpiredTokenError } from 'src/utils/utils';\nimport { ResponseErrorType } from 'src/@types/utils.type';\n\nexport class Http {\n  instance: AxiosInstance;\n  private accessToken: string;\n  private refreshToken: string;\n  private refreshTokenRequest: Promise<string> | null;\n  constructor() {\n    this.accessToken = getAccessTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshToken = getRefreshTokenFromLS(); //Khởi tạo 1 lần duy nhất và lưu access_token vào trong ram\n    this.refreshTokenRequest = null;\n    this.instance = axios.create({\n      baseURL: config.baseUrl,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'expire-access-token': 5, //5 giây\n        'expire-refresh-token': 60 * 60 // 1 giờ\n      }\n    });\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        if (this.accessToken && config.headers) {\n          config.headers.Authorization = this.accessToken;\n          /**\n           * Lấy accessToken từ đối thượng HTTP tức là lấy dữ liệu từ RAM\n           * Lấy accessToken từ localStorage tức là lấy dữ liệu từ ROM\n           * ==> lấy từ RAM sẽ cho tốc độ tải dữ liệu nhanh hơn lấy từ ROM\n           */\n        }\n        return config;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n\n    this.instance.interceptors.response.use(\n      (response) => {\n        // console.log(response);\n        const { url } = response.config;\n\n        if (url === URL_LOGIN || url === URL_REGISTER) {\n          const result = response.data as AuthResponse;\n\n          const { accessToken, username, refreshToken, avatar, roles } = result.data;\n          this.accessToken = accessToken;\n          this.refreshToken = refreshToken;\n          setAccessTokenToLS(accessToken);\n          setRefreshTokenToLS(refreshToken);\n          setProfileToLS({ id, username, roles: formattedRoles, avatar: avatar ?? undefined });\n        } else if (url === URL_LOGOUT) {\n          this.accessToken = '';\n          this.refreshToken = '';\n          clearLS();\n        }\n\n        return response;\n      },\n      (error: AxiosError) => {\n        //Chỉ toast những lỗi không liên quan 422 và 401\n        if (\n          ![HttpStatusCode.UnprocessableEntity, HttpStatusCode.Unauthorized].includes(error.response?.status as number)\n        ) {\n          const data: any = error.response?.data;\n          const message = data?.message || error.message;\n          toast.error(message);\n        }\n\n        //Lỗi 401 có nhiều trường hợp\n        // - trường hợp không truyền lên access_token\n        // - trường hợp truyền lên access_token không đúng\n        // - trường hợp refresh_token hết hạn\n        // - trường hợp truyền lên access_token hết hạn ==> tiến hành xử lý refresh_token\n\n        if (isAxiosErrorUnauthorized<ResponseErrorType<{ name: string; message: string }>>(error)) {\n          const config = error.response?.config || ({ headers: {} } as InternalAxiosRequestConfig);\n\n          const { url } = config;\n          //Trường hợp token hết hạn và request truyền đi không phải là api gọi refresh token\n          if (isExpiredTokenError(error) && url !== URL_REFRESH_TOKEN) {\n            this.refreshTokenRequest = this.refreshTokenRequest\n              ? this.refreshTokenRequest\n              : this.handleRefreshToken()?.finally(() => {\n                  //Giữ refreshToken trong 3s tiếp theo để những request tiếp theo bị 401 thì vẫn dùng requestTokenRequest này\n                  //Và số giây giữ phải nhỏ hơn thời gian hết hạn của refreshToken\n                  setTimeout(() => {\n                    this.refreshTokenRequest = null;\n                  }, 3000);\n                });\n\n            return this.refreshTokenRequest?.then((access_token) => {\n              if (config?.headers) {\n                //Nghĩa là chúng ta tiếp tục gọi lại request củ vừa bị lỗi\n                return this.instance({ ...config, headers: { ...config.headers, Authorization: access_token } });\n              }\n            });\n          }\n\n          //Còn những trường hợp như truyền sai token, token hết hạn và refreshToken cũng hết hạn thì toast message\n          // Và xóa toàn bộ token trong http và LS\n          this.accessToken = '';\n          this.refreshToken = '';\n          clearLS();\n          toast.error(error.response?.data.data?.message || error.response?.data.message);\n        }\n\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  private handleRefreshToken() {\n    return this.instance\n      .post<RefreshTokenResponse>(URL_REFRESH_TOKEN, { refresh_token: this.refreshToken })\n      .then((res) => {\n        const { access_token } = res.data.data;\n        this.accessToken = access_token;\n        setAccessTokenToLS(access_token);\n        return access_token;\n      })\n      .catch(() => {\n        clearLS();\n        this.accessToken = '';\n        this.refreshToken = '';\n        throw new Error();\n      });\n  }\n}\n\nconst api = new Http().instance;\n\nexport default api;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}