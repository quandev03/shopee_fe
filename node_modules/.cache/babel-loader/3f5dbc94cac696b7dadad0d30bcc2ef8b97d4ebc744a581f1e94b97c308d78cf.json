{"ast":null,"code":"import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\nfunction limitedDepthRecursive(n, f, g = () => undefined) {\n  if (n === undefined) {\n    const f1 = function (...args) {\n      return f(f1, ...args);\n    };\n    return f1;\n  }\n  if (n >= 0) {\n    return function (...args) {\n      return f(limitedDepthRecursive(n - 1, f, g), ...args);\n    };\n  }\n  return g;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacter(str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) {\n    ++start;\n  }\n  while (end > start && str[end - 1] === char) {\n    --end;\n  }\n  return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacterEnd(str, char) {\n  let end = str.length;\n  while (end > 0 && str[end - 1] === char) {\n    --end;\n  }\n  return end < str.length ? str.substring(0, end) : str;\n}\n\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\nfunction unicodeEscape(str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\nfunction mergeDuplicatesPreferLast(items, getKey) {\n  const map = new Map();\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(key, map.has(key) ? merge(item, map.get(key), {\n      arrayMerge: overwriteMerge$1\n    }) : item);\n  }\n  return [...map.values()].reverse();\n}\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\nfunction get(obj, path) {\n  for (const key of path) {\n    if (!obj) {\n      return undefined;\n    }\n    obj = obj[key];\n  }\n  return obj;\n}\n\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\nfunction numberToLetterSequence(num, baseChar = 'a', base = 26) {\n  const digits = [];\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = num / base >> 0; // quick `floor`\n  } while (num > 0);\n  const baseCode = baseChar.charCodeAt(0);\n  return digits.reverse().map(n => String.fromCharCode(baseCode + n)).join('');\n}\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\nfunction numberToRoman(num) {\n  return [...(num + '')].map(n => +n).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join('');\n}\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor(options, maxLineLength = undefined) {\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  pushWord(word, noWrap = false) {\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if (cost <= this.nextLineAvailableChars || noWrap) {\n      // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n    } else {\n      // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) {\n        this.startNewLine();\n      }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord() {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  concatWord(word, noWrap = false) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine(n = 1) {\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({\n        length: n - 1\n      }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty() {\n    return this.lines.length === 0 && this.nextLineWords.length === 0;\n  }\n  clear() {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return [...this.lines, this.nextLineWords].map(words => words.join(' ')).join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord(word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n      if (splitIndex > -1) {\n        // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n      } else {\n        // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) {\n          // There is next character to try\n\n          word = firstLine + remainingChars;\n        } else {\n          // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n        }\n      }\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\n/* eslint-disable max-classes-per-file */\n\nclass StackItem {\n  constructor(next = null) {\n    this.next = next;\n  }\n  getRoot() {\n    return this.next ? this.next : this;\n  }\n}\nclass BlockStackItem extends StackItem {\n  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass ListStackItem extends BlockStackItem {\n  constructor(options, next = null, {\n    interRowLineBreaks = 1,\n    leadingLineBreaks = 2,\n    maxLineLength = undefined,\n    maxPrefixLength = 0,\n    prefixAlign = 'left'\n  } = {}) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n}\nclass ListItemStackItem extends BlockStackItem {\n  constructor(options, next = null, {\n    leadingLineBreaks = 1,\n    maxLineLength = undefined,\n    prefix = ''\n  } = {}) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n}\nclass TableStackItem extends StackItem {\n  constructor(next = null) {\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TableRowStackItem extends StackItem {\n  constructor(next = null) {\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TableCellStackItem extends StackItem {\n  constructor(options, next = null, maxColumnWidth = undefined) {\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TransformerStackItem extends StackItem {\n  constructor(next = null, transform) {\n    super(next);\n    this.transform = transform;\n  }\n}\nfunction charactersToCodes(str) {\n  return [...str].map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor(options) {\n    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, '') : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n    if (options.preserveNewlines) {\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = str => str, noWrap = false) {\n        if (!text) {\n          return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n    } else {\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = str => str, noWrap = false) {\n        if (!text) {\n          return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n      };\n    }\n  }\n\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n  addLiteral(text, inlineTextBuilder, noWrap = true) {\n    if (!text) {\n      return;\n    }\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n    if (m) {\n      anyMatch = true;\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace(text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace(text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords(text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n  countNewlinesNoWords(text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n    return counter;\n  }\n}\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor(options, picker, metadata = undefined) {\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform(wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform() {\n    if (!this._wordTransformer) {\n      return undefined;\n    }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n  startNoWrap() {\n    this._stackItem.isNoWrap = true;\n  }\n\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n  stopNoWrap() {\n    this._stackItem.isNoWrap = false;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer() {\n    const wt = this._wordTransformer ? str => applyTransformer(str, this._wordTransformer) : undefined;\n    const ce = this.options.encodeCharacters;\n    return wt ? ce ? str => ce(wt(str)) : wt : ce;\n  }\n  _popStackItem() {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak() {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity() {\n    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n  addInline(str, {\n    noWordTransform = false\n  } = {}) {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n    if (str.length === 0 ||\n    // empty string\n\n    this._stackItem.stashedLineBreaks &&\n    // stashed linebreaks make whitespace irrelevant\n    !this.whitespaceProcessor.testContainsWords(str) // no words to add\n    ) {\n      return;\n    }\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n  addLiteral(str) {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (str.length === 0) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0;\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n  openBlock({\n    leadingLineBreaks = 1,\n    reservedLineLength = 0,\n    isPre = false\n  } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n    if (isPre) {\n      this._stackItem.isPre = true;\n    }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n  closeBlock({\n    trailingLineBreaks = 1,\n    blockTransform = undefined\n  } = {}) {\n    const block = this._popStackItem();\n    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n  openList({\n    maxPrefixLength = 0,\n    prefixAlign = 'left',\n    interRowLineBreaks = 1,\n    leadingLineBreaks = 2\n  } = {}) {\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n  openListItem({\n    prefix = ''\n  } = {}) {\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n  closeListItem() {\n    const listItem = this._popStackItem();\n    const list = listItem.next;\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = list.prefixAlign === 'right' ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n    addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n  }\n\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n  closeList({\n    trailingLineBreaks = 2\n  } = {}) {\n    const list = this._popStackItem();\n    const text = getText(list);\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable() {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow() {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell({\n    maxColumnWidth = undefined\n  } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n  closeTableCell({\n    colspan = 1,\n    rowspan = 1\n  } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({\n      colspan: colspan,\n      rowspan: rowspan,\n      text: text\n    });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow() {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n  closeTable({\n    tableToString,\n    leadingLineBreaks = 2,\n    trailingLineBreaks = 2\n  }) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n}\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\nfunction applyTransformer(str, transformer) {\n  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile$1(options = {}) {\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n  if (selectorsWithoutFormat.length) {\n    throw new Error('Following selectors have no specified format: ' + selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', '));\n  }\n  const picker = new DecisionTree(options.selectors.map(s => [s.selector, s])).build(hp2Builder);\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s, i) => [s, i + 1])).build(hp2Builder);\n  function findBaseElements(dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function (dom, builder) {\n    builder.addInline(options.limits.ellipsis || '');\n  });\n  return function (html, metadata = undefined) {\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\nfunction process(html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n    html = html.substring(0, maxInputLength);\n  }\n  const document = parseDocument(html, {\n    decodeEntities: options.decodeEntities\n  });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\nfunction findBases(dom, options, baseSelectorsPicker) {\n  const results = [];\n  function recursiveWalk(walk, /** @type { DomNode[] } */dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n      if (pickedSelectorIndex > 0) {\n        results.push({\n          selectorIndex: pickedSelectorIndex,\n          element: elem\n        });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n  limitedWalk(dom);\n  if (options.baseElements.orderBy !== 'occurrence') {\n    // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map(x => x.element);\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk(walk, dom, builder) {\n  if (!dom) {\n    return;\n  }\n  const options = builder.options;\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text':\n        {\n          builder.addInline(elem.data);\n          break;\n        }\n      case 'tag':\n        {\n          const tagDefinition = builder.picker.pick1(elem);\n          const format = options.formatters[tagDefinition.format];\n          format(elem, walk, builder, tagDefinition.options || {});\n          break;\n        }\n    }\n  }\n  return;\n}\n\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\nfunction makeReplacerFromDict(dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n  const entries = Object.entries(dict).filter(([, v]) => v !== false);\n  const regex = new RegExp(entries.map(([c]) => `(${unicodeEscape([...c][0])})`).join('|'), 'g');\n  const values = entries.map(([, v]) => v);\n  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];\n  return str => str.replace(regex, replacer);\n}\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineString(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockString(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock$1(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\nfunction renderOpenTag(elem) {\n  const attrs = elem.attribs && elem.attribs.length ? ' ' + Object.entries(elem.attribs).map(([k, v]) => v === '' ? k : `${k}=${v.replace(/\"/g, '&quot;')}`).join(' ') : '';\n  return `<${elem.name}${attrs}>`;\n}\nfunction renderCloseTag(elem) {\n  return `</${elem.name}>`;\n}\n\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineTag(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockTag(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineHtml(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockHtml(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineSurround(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\nfunction getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n  return matrix[j];\n}\nfunction findFirstVacantIndex(row, x = 0) {\n  while (row[x]) {\n    x++;\n  }\n  return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      if (rowI[j] || rowJ[i]) {\n        const temp = rowI[j];\n        rowI[j] = rowJ[i];\n        rowJ[i] = temp;\n      }\n    }\n  }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\nfunction getOrInitOffset(offsets, index) {\n  if (offsets[index] === undefined) {\n    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);\n  }\n  return offsets[index];\n}\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);\n}\n\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);\n    while (y < rowsInThisColumn) {\n      cell = layout[x][y];\n      if (cell) {\n        if (!cell.rendered) {\n          let cellWidth = 0;\n          for (let j = 0; j < cell.lines.length; j++) {\n            const line = cell.lines[j];\n            const lineOffset = rowOffsets[y] + j;\n            outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n            cellWidth = line.length > cellWidth ? line.length : cellWidth;\n          }\n          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n          cell.rendered = true;\n        }\n        y += cell.rowspan;\n      } else {\n        const lineOffset = rowOffsets[y];\n        outputLines[lineOffset] = outputLines[lineOffset] || '';\n        y++;\n      }\n    }\n  }\n  return outputLines.join('\\n');\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(line => '> ' + line).join('\\n')\n  });\n}\nfunction withBrackets(str, brackets) {\n  if (!brackets) {\n    return str;\n  }\n  const lbr = typeof brackets[0] === 'string' ? brackets[0] : '[';\n  const rbr = typeof brackets[1] === 'string' ? brackets[1] : ']';\n  return lbr + str + rbr;\n}\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = typeof rewriter === 'function' ? rewriter(path, metadata, elem) : path;\n  return modifiedPath[0] === '/' && baseUrl ? trimCharacterEnd(baseUrl, '/') + modifiedPath : modifiedPath;\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage(elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = attribs.alt ? attribs.alt : '';\n  const src = !attribs.src ? '' : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n  builder.addInline(text, {\n    noWordTransform: true\n  });\n}\n\n// a img baseUrl\n// a img pathRewrite\n// a img linkBrackets\n\n// a     ignoreHref: false\n//            ignoreText ?\n// a     noAnchorUrl: true\n//            can be replaced with selector\n// a     hideLinkHrefIfSameAsText: false\n//            how to compare, what to show (text, href, normalized) ?\n// a     mailto protocol removed without options\n\n// a     protocols: mailto, tel, ...\n//            can be matched with selector?\n\n// anchors, protocols - only if no pathRewrite fn is provided\n\n// normalize-url ?\n\n// a\n// a[href^=\"#\"] - format:skip by default\n// a[href^=\"mailto:\"] - ?\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(str => {\n      if (str) {\n        text += str;\n      }\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : ' ' + withBrackets(href, formatOptions.linkBrackets), {\n        noWordTransform: true\n      });\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || []\n  // it might be more accurate to check only for html spaces here, but no significant benefit\n  ).filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data)).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n  if (!listItems.length) {\n    return;\n  }\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n  for (const {\n    node,\n    prefix\n  } of listItems) {\n    builder.openListItem({\n      prefix: prefix\n    });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n  builder.closeList({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction(olType = '1') {\n  switch (olType) {\n    case 'a':\n      return i => numberToLetterSequence(i, 'a');\n    case 'A':\n      return i => numberToLetterSequence(i, 'A');\n    case 'i':\n      return i => numberToRoman(i).toLowerCase();\n    case 'I':\n      return i => numberToRoman(i);\n    case '1':\n    default:\n      return i => i.toString();\n  }\n}\n\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\nfunction splitClassesAndIds(selectors) {\n  const classes = [];\n  const ids = [];\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n  return {\n    classes: classes,\n    ids: ids\n  };\n}\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n  if (!attr) {\n    return false;\n  }\n  const {\n    classes,\n    ids\n  } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: rows => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n  function formatCell(cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? cellNode => {\n      builder.pushWordTransform(str => str.toUpperCase());\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n      case 'tr':\n        {\n          builder.openTableRow();\n          for (const childOfTr of elem.children) {\n            if (childOfTr.type !== 'tag') {\n              continue;\n            }\n            switch (childOfTr.name) {\n              case 'th':\n                {\n                  formatHeaderCell(childOfTr);\n                  break;\n                }\n              case 'td':\n                {\n                  formatCell(childOfTr);\n                  break;\n                }\n              // do nothing\n            }\n          }\n          builder.closeTableRow();\n          break;\n        }\n      // do nothing\n    }\n  }\n}\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: ['body'],\n    orderBy: 'selectors',\n    // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: 1 << 24 // 16_777_216\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [{\n    selector: '*',\n    format: 'inline'\n  }, {\n    selector: 'a',\n    format: 'anchor',\n    options: {\n      baseUrl: null,\n      hideLinkHrefIfSameAsText: false,\n      ignoreHref: false,\n      linkBrackets: ['[', ']'],\n      noAnchorUrl: true\n    }\n  }, {\n    selector: 'article',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'aside',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'blockquote',\n    format: 'blockquote',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      trimEmptyLines: true\n    }\n  }, {\n    selector: 'br',\n    format: 'lineBreak'\n  }, {\n    selector: 'div',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'footer',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'form',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'h1',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h2',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h3',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h4',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h5',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h6',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'header',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'hr',\n    format: 'horizontalLine',\n    options: {\n      leadingLineBreaks: 2,\n      length: undefined,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'img',\n    format: 'image',\n    options: {\n      baseUrl: null,\n      linkBrackets: ['[', ']']\n    }\n  }, {\n    selector: 'main',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'nav',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'ol',\n    format: 'orderedList',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'p',\n    format: 'paragraph',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'pre',\n    format: 'pre',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'section',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'table',\n    format: 'table',\n    options: {\n      colSpacing: 3,\n      leadingLineBreaks: 2,\n      maxColumnWidth: 60,\n      rowSpacing: 0,\n      trailingLineBreaks: 2,\n      uppercaseHeaderCells: true\n    }\n  }, {\n    selector: 'ul',\n    format: 'unorderedList',\n    options: {\n      itemPrefix: ' * ',\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'wbr',\n    format: 'wbr'\n  }],\n  tables: [],\n  // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\nconst concatMerge = (acc, src, options) => [...acc, ...src];\nconst overwriteMerge = (acc, src, options) => [...src];\nconst selectorsMerge = (acc, src, options) => acc.some(s => typeof s === 'object') ? concatMerge(acc, src) // selectors\n: overwriteMerge(acc, src) // baseElements.selectors\n;\n\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile(options = {}) {\n  options = merge(DEFAULT_OPTIONS, options, {\n    arrayMerge: overwriteMerge,\n    customMerge: key => key === 'selectors' ? selectorsMerge : undefined\n  });\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  handleDeprecatedOptions(options);\n  return compile$1(options);\n}\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction convert(html, options = {}, metadata = undefined) {\n  return compile(options)(html, metadata);\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions(options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({\n      ...definition,\n      selector: selector || '*'\n    }));\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  }\n  function set(obj, path, value) {\n    const valueKey = path.pop();\n    for (const key of path) {\n      let nested = obj[key];\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n      obj = nested;\n    }\n    obj[valueKey] = value;\n  }\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(options, ['baseElements', 'selectors'], Array.isArray(baseElement) ? baseElement : [baseElement]);\n  }\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\nexport { compile, convert, convert as htmlToText };","map":{"version":3,"names":["hp2Builder","parseDocument","DecisionTree","merge","render","limitedDepthRecursive","n","f","g","undefined","f1","args","trimCharacter","str","char","start","end","length","substring","trimCharacterEnd","unicodeEscape","replace","c","charCodeAt","toString","padStart","mergeDuplicatesPreferLast","items","getKey","map","Map","i","item","key","set","has","get","arrayMerge","overwriteMerge$1","values","reverse","acc","src","options","obj","path","numberToLetterSequence","num","baseChar","base","digits","push","baseCode","String","fromCharCode","join","I","V","numberToRoman","v","repeat","InlineTextBuilder","constructor","maxLineLength","lines","nextLineWords","wordwrap","Number","MAX_VALUE","nextLineAvailableChars","wrapCharacters","forceWrapOnLimit","stashedSpace","wordBreakOpportunity","pushWord","word","noWrap","startNewLine","isLineStart","cost","first","rest","splitLongWord","part","popWord","lastWord","pop","concatWord","concat","Array","from","isEmpty","clear","words","parts","idx","firstLine","remainingChars","splitIndex","lastIndexOf","StackItem","next","getRoot","BlockStackItem","leadingLineBreaks","inlineTextBuilder","rawText","stashedLineBreaks","isPre","isNoWrap","ListStackItem","interRowLineBreaks","maxPrefixLength","prefixAlign","ListItemStackItem","prefix","TableStackItem","rows","TableRowStackItem","cells","TableCellStackItem","maxColumnWidth","TransformerStackItem","transform","charactersToCodes","WhitespaceProcessor","whitespaceChars","preserveNewlines","whitespaceCharacters","whitespaceCodes","leadingWhitespaceRe","RegExp","trailingWhitespaceRe","allWhitespaceOrEmptyRe","newlineOrNonWhitespaceRe","newlineOrNonNewlineStringRe","wordOrNewlineRe","shrinkWrapAdd","text","previouslyStashedSpace","anyMatch","m","exec","testLeadingWhitespace","testTrailingWhitespace","wordRe","addLiteral","test","testContainsWords","countNewlinesNoWords","lastIndex","counter","match","BlockTextBuilder","picker","metadata","whitespaceProcessor","_stackItem","_wordTransformer","pushWordTransform","wordTransform","popWordTransform","startNoWrap","stopNoWrap","_getCombinedWordTransformer","wt","applyTransformer","ce","encodeCharacters","_popStackItem","addLineBreak","addWordBreakOpportunity","addInline","noWordTransform","newlinesNumber","openBlock","reservedLineLength","Math","max","closeBlock","trailingLineBreaks","blockTransform","block","blockText","getText","addText","openList","openListItem","Error","list","prefixLength","closeListItem","listItem","spacing","padEnd","closeList","openTable","openTableRow","openTableCell","closeTableCell","colspan","rowspan","cell","closeTableRow","row","closeTable","tableToString","table","output","stackItem","parentText","lineBreaks","transformer","compile$1","selectorsWithoutFormat","selectors","filter","s","format","selector","build","makeReplacerFromDict","baseSelectorsPicker","baseElements","findBaseElements","dom","findBases","limitedWalk","limits","maxDepth","recursiveWalk","builder","ellipsis","html","process","walk","maxInputLength","console","warn","document","decodeEntities","bases","children","results","slice","maxChildNodes","elem","type","pickedSelectorIndex","pick1","selectorIndex","element","maxBaseElements","orderBy","sort","a","b","returnDomByDefault","x","tooManyChildNodes","data","tagDefinition","formatters","dict","Object","keys","entries","regex","replacer","cgs","findIndex","cg","formatSkip","formatOptions","formatInlineString","string","formatBlockString","formatInline","formatBlock$1","renderOpenTag","attrs","attribs","k","name","renderCloseTag","formatInlineTag","formatBlockTag","formatInlineHtml","formatBlockHtml","formatInlineSurround","suffix","genericFormatters","freeze","__proto__","blockHtml","blockString","blockTag","inline","inlineHtml","inlineString","inlineSurround","inlineTag","skip","getRow","matrix","j","findFirstVacantIndex","transposeInPlace","maxSize","rowI","rowJ","temp","putCellIntoLayout","layout","baseRow","baseCol","r","layoutRow","getOrInitOffset","offsets","index","updateOffset","span","value","tableRows","rowSpacing","colSpacing","colNumber","rowNumber","rowOffsets","split","cellHeight","outputLines","colOffsets","y","rowsInThisColumn","min","rendered","cellWidth","line","lineOffset","formatLineBreak","formatWbr","formatHorizontalLine","formatParagraph","formatPre","formatHeading","uppercase","toUpperCase","formatBlockquote","trimEmptyLines","withBrackets","brackets","lbr","rbr","pathRewrite","rewriter","baseUrl","modifiedPath","formatImage","alt","linkBrackets","formatAnchor","getHref","ignoreHref","href","noAnchorUrl","hideSameLink","hideLinkHrefIfSameAsText","formatList","nextPrefixCallback","isNestedList","listItems","child","node","trimStart","formatUnorderedList","itemPrefix","formatOrderedList","nextIndex","indexFunction","getOrderedListIndexFunction","olType","toLowerCase","splitClassesAndIds","classes","ids","startsWith","isDataTable","attr","tables","attrClasses","attrIds","some","includes","formatTable","formatDataTable","formatBlock","forEach","walkTable","formatCell","cellNode","formatHeaderCell","uppercaseHeaderCells","childOfTr","textFormatters","anchor","blockquote","dataTable","heading","horizontalLine","image","lineBreak","orderedList","paragraph","pre","unorderedList","wbr","DEFAULT_OPTIONS","longWordSplit","concatMerge","overwriteMerge","selectorsMerge","compile","customMerge","assign","handleDeprecatedOptions","convert","tags","tagDefinitions","definition","valueKey","nested","baseElement","isArray","htmlToText"],"sources":["/Volumes/MAC_Quandev03/Code/JS/ShopeeClone/ShopeeClone/node_modules/html-to-text/lib/html-to-text.mjs"],"sourcesContent":["import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\nfunction limitedDepthRecursive (n, f, g = () => undefined) {\n  if (n === undefined) {\n    const f1 = function (...args) { return f(f1, ...args); };\n    return f1;\n  }\n  if (n >= 0) {\n    return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };\n  }\n  return g;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacter (str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) { ++start; }\n  while (end > start && str[end - 1] === char) { --end; }\n  return (start > 0 || end < str.length)\n    ? str.substring(start, end)\n    : str;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacterEnd (str, char) {\n  let end = str.length;\n  while (end > 0 && str[end - 1] === char) { --end; }\n  return (end < str.length)\n    ? str.substring(0, end)\n    : str;\n}\n\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\nfunction unicodeEscape (str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\nfunction mergeDuplicatesPreferLast (items, getKey) {\n  const map = new Map();\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(\n      key,\n      (map.has(key))\n        ? merge(item, map.get(key), { arrayMerge: overwriteMerge$1 })\n        : item\n    );\n  }\n  return [...map.values()].reverse();\n}\n\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\nfunction get (obj, path) {\n  for (const key of path) {\n    if (!obj) { return undefined; }\n    obj = obj[key];\n  }\n  return obj;\n}\n\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\nfunction numberToLetterSequence (num, baseChar = 'a', base = 26) {\n  const digits = [];\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = (num / base) >> 0; // quick `floor`\n  } while (num > 0);\n  const baseCode = baseChar.charCodeAt(0);\n  return digits\n    .reverse()\n    .map(n => String.fromCharCode(baseCode + n))\n    .join('');\n}\n\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\nfunction numberToRoman (num) {\n  return [...(num) + '']\n    .map(n => +n)\n    .reverse()\n    .map((v, i) => ((v % 5 < 4)\n      ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)\n      : I[i] + (v < 5 ? V[i] : I[i + 1])))\n    .reverse()\n    .join('');\n}\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor (options, maxLineLength = undefined) {\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  pushWord (word, noWrap = false) {\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n\n    } else { // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) { this.startNewLine(); }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord () {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  concatWord (word, noWrap = false) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine (n = 1) {\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({ length: n - 1 }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty () {\n    return this.lines.length === 0\n        && this.nextLineWords.length === 0;\n  }\n\n  clear () {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return [...this.lines, this.nextLineWords]\n      .map(words => words.join(' '))\n      .join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord (word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n\n      if (splitIndex > -1) { // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n\n      } else { // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) { // There is next character to try\n\n          word = firstLine + remainingChars;\n\n        } else { // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n\n        }\n\n      }\n\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\n/* eslint-disable max-classes-per-file */\n\n\nclass StackItem {\n  constructor (next = null) { this.next = next; }\n\n  getRoot () { return (this.next) ? this.next : this; }\n}\n\nclass BlockStackItem extends StackItem {\n  constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass ListStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2,\n      maxLineLength = undefined,\n      maxPrefixLength = 0,\n      prefixAlign = 'left',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n}\n\nclass ListItemStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      leadingLineBreaks = 1,\n      maxLineLength = undefined,\n      prefix = '',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n}\n\nclass TableStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableRowStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableCellStackItem extends StackItem {\n  constructor (options, next = null, maxColumnWidth = undefined) {\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TransformerStackItem extends StackItem {\n  constructor (next = null, transform) {\n    super(next);\n    this.transform = transform;\n  }\n}\n\nfunction charactersToCodes (str) {\n  return [...str]\n    .map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))\n    .join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor (options) {\n    this.whitespaceChars = (options.preserveNewlines)\n      ? options.whitespaceCharacters.replace(/\\n/g, '')\n      : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n\n    if (options.preserveNewlines) {\n\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n\n    } else {\n\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);\n      };\n\n    }\n  }\n\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n  addLiteral (text, inlineTextBuilder, noWrap = true) {\n    if (!text) { return; }\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n    if (m) {\n      anyMatch = true;\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n    inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace (text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace (text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords (text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n  countNewlinesNoWords (text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n    return counter;\n  }\n\n}\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor (options, picker, metadata = undefined) {\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n  startNoWrap () {\n    this._stackItem.isNoWrap = true;\n  }\n\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n  stopNoWrap () {\n    this._stackItem.isNoWrap = false;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const wt = (this._wordTransformer)\n      ? ((str) => applyTransformer(str, this._wordTransformer))\n      : undefined;\n    const ce = this.options.encodeCharacters;\n    return (wt)\n      ? ((ce) ? (str) => ce(wt(str)) : wt)\n      : ce;\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n  addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      str.length === 0 || // empty string\n      (\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n      )\n    ) { return; }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(\n      str,\n      this._stackItem.inlineTextBuilder,\n      (noWordTransform) ? undefined : this._getCombinedWordTransformer(),\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n  addLiteral (str) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (str.length === 0) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.addLiteral(\n      str,\n      this._stackItem.inlineTextBuilder,\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0;\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n  openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n  closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n  openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n  openListItem ({ prefix = '' } = {}) {\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n  closeListItem () {\n    const listItem = this._popStackItem();\n    const list = listItem.next;\n\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = (list.prefixAlign === 'right')\n      ? listItem.prefix.padStart(prefixLength)\n      : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n\n    addText(\n      list,\n      text,\n      listItem.leadingLineBreaks,\n      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)\n    );\n  }\n\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n  closeList ({ trailingLineBreaks = 2 } = {}) {\n    const list = this._popStackItem();\n    const text = getText(list);\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n  closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n  closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\nfunction applyTransformer (str, transformer) {\n  return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n}\n\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile$1 (options = {}) {\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n  if (selectorsWithoutFormat.length) {\n    throw new Error(\n      'Following selectors have no specified format: ' +\n      selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', ')\n    );\n  }\n  const picker = new DecisionTree(\n    options.selectors.map(s => [s.selector, s])\n  ).build(hp2Builder);\n\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n\n  const baseSelectorsPicker = new DecisionTree(\n    options.baseElements.selectors.map((s, i) => [s, i + 1])\n  ).build(hp2Builder);\n  function findBaseElements (dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk,\n    function (dom, builder) {\n      builder.addInline(options.limits.ellipsis || '');\n    }\n  );\n\n  return function (html, metadata = undefined) {\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n\n\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\nfunction process (html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(\n      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`\n    );\n    html = html.substring(0, maxInputLength);\n  }\n\n  const document = parseDocument(html, { decodeEntities: options.decodeEntities });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\n\n\nfunction findBases (dom, options, baseSelectorsPicker) {\n  const results = [];\n\n  function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n      if (pickedSelectorIndex > 0) {\n        results.push({ selectorIndex: pickedSelectorIndex, element: elem });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk\n  );\n  limitedWalk(dom);\n\n  if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n  return (options.baseElements.returnDomByDefault && results.length === 0)\n    ? dom\n    : results.map(x => x.element);\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk (walk, dom, builder) {\n  if (!dom) { return; }\n\n  const options = builder.options;\n\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text': {\n        builder.addInline(elem.data);\n        break;\n      }\n      case 'tag': {\n        const tagDefinition = builder.picker.pick1(elem);\n        const format = options.formatters[tagDefinition.format];\n        format(elem, walk, builder, tagDefinition.options || {});\n        break;\n      }\n    }\n  }\n\n  return;\n}\n\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\nfunction makeReplacerFromDict (dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n  const entries = Object.entries(dict).filter(([, v]) => v !== false);\n  const regex = new RegExp(\n    entries\n      .map(([c]) => `(${unicodeEscape([...c][0])})`)\n      .join('|'),\n    'g'\n  );\n  const values = entries.map(([, v]) => v);\n  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];\n  return (str) => str.replace(regex, replacer);\n}\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip (elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineString (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockString (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline (elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock$1 (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\nfunction renderOpenTag (elem) {\n  const attrs = (elem.attribs && elem.attribs.length)\n    ? ' ' + Object.entries(elem.attribs)\n      .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/\"/g, '&quot;')}`))\n      .join(' ')\n    : '';\n  return `<${elem.name}${attrs}>`;\n}\n\nfunction renderCloseTag (elem) {\n  return `</${elem.name}>`;\n}\n\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineTag (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockTag (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineHtml (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockHtml (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineSurround (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\n\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\n\nfunction getRow (matrix, j) {\n  if (!matrix[j]) { matrix[j] = []; }\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex (row, x = 0) {\n  while (row[x]) { x++; }\n  return x;\n}\n\nfunction transposeInPlace (matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      if (rowI[j] || rowJ[i]) {\n        const temp = rowI[j];\n        rowI[j] = rowJ[i];\n        rowJ[i] = temp;\n      }\n    }\n  }\n}\n\nfunction putCellIntoLayout (cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction getOrInitOffset (offsets, index) {\n  if (offsets[index] === undefined) {\n    offsets[index] = (index === 0) ? 0 : 1 + getOrInitOffset(offsets, index - 1);\n  }\n  return offsets[index];\n}\n\nfunction updateOffset (offsets, base, span, value) {\n  offsets[base + span] = Math.max(\n    getOrInitOffset(offsets, base + span),\n    getOrInitOffset(offsets, base) + value\n  );\n}\n\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString (tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);\n\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);\n    while (y < rowsInThisColumn) {\n      cell = layout[x][y];\n      if (cell) {\n        if (!cell.rendered) {\n          let cellWidth = 0;\n          for (let j = 0; j < cell.lines.length; j++) {\n            const line = cell.lines[j];\n            const lineOffset = rowOffsets[y] + j;\n            outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n            cellWidth = (line.length > cellWidth) ? line.length : cellWidth;\n          }\n          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n          cell.rendered = true;\n        }\n        y += cell.rowspan;\n      } else {\n        const lineOffset = rowOffsets[y];\n        outputLines[lineOffset] = (outputLines[lineOffset] || '');\n        y++;\n      }\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak (elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr (elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\\n') : str)\n      .split('\\n')\n      .map(line => '> ' + line)\n      .join('\\n')\n  });\n}\n\nfunction withBrackets (str, brackets) {\n  if (!brackets) { return str; }\n\n  const lbr = (typeof brackets[0] === 'string')\n    ? brackets[0]\n    : '[';\n  const rbr = (typeof brackets[1] === 'string')\n    ? brackets[1]\n    : ']';\n  return lbr + str + rbr;\n}\n\nfunction pathRewrite (path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = (typeof rewriter === 'function')\n    ? rewriter(path, metadata, elem)\n    : path;\n  return (modifiedPath[0] === '/' && baseUrl)\n    ? trimCharacterEnd(baseUrl, '/') + modifiedPath\n    : modifiedPath;\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage (elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = (attribs.alt)\n    ? attribs.alt\n    : '';\n  const src = (!attribs.src)\n    ? ''\n    : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = (!src)\n    ? alt\n    : (!alt)\n      ? withBrackets(src, formatOptions.linkBrackets)\n      : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n\n  builder.addInline(text, { noWordTransform: true });\n}\n\n// a img baseUrl\n// a img pathRewrite\n// a img linkBrackets\n\n// a     ignoreHref: false\n//            ignoreText ?\n// a     noAnchorUrl: true\n//            can be replaced with selector\n// a     hideLinkHrefIfSameAsText: false\n//            how to compare, what to show (text, href, normalized) ?\n// a     mailto protocol removed without options\n\n// a     protocols: mailto, tel, ...\n//            can be matched with selector?\n\n// anchors, protocols - only if no pathRewrite fn is provided\n\n// normalize-url ?\n\n// a\n// a[href^=\"#\"] - format:skip by default\n// a[href^=\"mailto:\"] - ?\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor (elem, walk, builder, formatOptions) {\n  function getHref () {\n    if (formatOptions.ignoreHref) { return ''; }\n    if (!elem.attribs || !elem.attribs.href) { return ''; }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(\n      str => {\n        if (str) { text += str; }\n        return str;\n      }\n    );\n    walk(elem.children, builder);\n    builder.popWordTransform();\n\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(\n        (!text)\n          ? href\n          : ' ' + withBrackets(href, formatOptions.linkBrackets),\n        { noWordTransform: true }\n      );\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\nfunction formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [])\n    // it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data))\n    .map(function (child) {\n      if (child.name !== 'li') {\n        return { node: child, prefix: '' };\n      }\n      const prefix = (isNestedList)\n        ? nextPrefixCallback().trimStart()\n        : nextPrefixCallback();\n      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }\n      return { node: child, prefix: prefix };\n    });\n  if (!listItems.length) { return; }\n\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n\n  for (const { node, prefix } of listItems) {\n    builder.openListItem({ prefix: prefix });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n\n  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList (elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList (elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction (olType = '1') {\n  switch (olType) {\n    case 'a': return (i) => numberToLetterSequence(i, 'a');\n    case 'A': return (i) => numberToLetterSequence(i, 'A');\n    case 'i': return (i) => numberToRoman(i).toLowerCase();\n    case 'I': return (i) => numberToRoman(i);\n    case '1':\n    default: return (i) => (i).toString();\n  }\n}\n\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\nfunction splitClassesAndIds (selectors) {\n  const classes = [];\n  const ids = [];\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n  return { classes: classes, ids: ids };\n}\n\nfunction isDataTable (attr, tables) {\n  if (tables === true) { return true; }\n  if (!attr) { return false; }\n\n  const { classes, ids } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable (elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables)\n    ? formatDataTable(elem, walk, builder, formatOptions)\n    : formatBlock(elem, walk, builder, formatOptions);\n}\n\nfunction formatBlock (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable (elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell (cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });\n  }\n\n  function walkTable (elem) {\n    if (elem.type !== 'tag') { return; }\n\n    const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)\n      ? (cellNode) => {\n        builder.pushWordTransform(str => str.toUpperCase());\n        formatCell(cellNode);\n        builder.popWordTransform();\n      }\n      : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr': {\n        builder.openTableRow();\n        for (const childOfTr of elem.children) {\n          if (childOfTr.type !== 'tag') { continue; }\n          switch (childOfTr.name) {\n            case 'th': {\n              formatHeaderCell(childOfTr);\n              break;\n            }\n            case 'td': {\n              formatCell(childOfTr);\n              break;\n            }\n              // do nothing\n          }\n        }\n        builder.closeTableRow();\n        break;\n      }\n        // do nothing\n    }\n  }\n}\n\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: [ 'body' ],\n    orderBy: 'selectors', // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: (1 << 24) // 16_777_216\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [\n    { selector: '*', format: 'inline' },\n    {\n      selector: 'a',\n      format: 'anchor',\n      options: {\n        baseUrl: null,\n        hideLinkHrefIfSameAsText: false,\n        ignoreHref: false,\n        linkBrackets: ['[', ']'],\n        noAnchorUrl: true\n      }\n    },\n    { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'blockquote',\n      format: 'blockquote',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }\n    },\n    { selector: 'br', format: 'lineBreak' },\n    { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'hr',\n      format: 'horizontalLine',\n      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }\n    },\n    {\n      selector: 'img',\n      format: 'image',\n      options: { baseUrl: null, linkBrackets: ['[', ']'] }\n    },\n    { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'ol',\n      format: 'orderedList',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'table',\n      format: 'table',\n      options: {\n        colSpacing: 3,\n        leadingLineBreaks: 2,\n        maxColumnWidth: 60,\n        rowSpacing: 0,\n        trailingLineBreaks: 2,\n        uppercaseHeaderCells: true\n      }\n    },\n    {\n      selector: 'ul',\n      format: 'unorderedList',\n      options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'wbr', format: 'wbr' },\n  ],\n  tables: [], // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\n\nconst concatMerge = (acc, src, options) => [...acc, ...src];\nconst overwriteMerge = (acc, src, options) => [...src];\nconst selectorsMerge = (acc, src, options) => (\n  (acc.some(s => typeof s === 'object'))\n    ? concatMerge(acc, src) // selectors\n    : overwriteMerge(acc, src) // baseElements.selectors\n);\n\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile (options = {}) {\n  options = merge(\n    DEFAULT_OPTIONS,\n    options,\n    {\n      arrayMerge: overwriteMerge,\n      customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)\n    }\n  );\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n\n  handleDeprecatedOptions(options);\n\n  return compile$1(options);\n}\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction convert (html, options = {}, metadata = undefined) {\n  return compile(options)(html, metadata);\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions (options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(\n      ([selector, definition]) => ({ ...definition, selector: selector || '*' })\n    );\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n  }\n\n  function set (obj, path, value) {\n    const valueKey = path.pop();\n    for (const key of path) {\n      let nested = obj[key];\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n      obj = nested;\n    }\n    obj[valueKey] = value;\n  }\n\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(\n      options,\n      ['baseElements', 'selectors'],\n      (Array.isArray(baseElement) ? baseElement : [baseElement])\n    );\n  }\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\n\nexport { compile, convert, convert as htmlToText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}