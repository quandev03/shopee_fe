{"ast":null,"code":"import { createLexer } from 'leac';\nimport * as p from 'peberminta';\nvar ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst ws = `(?:[ \\\\t\\\\r\\\\n\\\\f]*)`;\nconst nl = `(?:\\\\n|\\\\r\\\\n|\\\\r|\\\\f)`;\nconst nonascii = `[^\\\\x00-\\\\x7F]`;\nconst unicode = `(?:\\\\\\\\[0-9a-f]{1,6}(?:\\\\r\\\\n|[ \\\\n\\\\r\\\\t\\\\f])?)`;\nconst escape = `(?:\\\\\\\\[^\\\\n\\\\r\\\\f0-9a-f])`;\nconst nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;\nconst nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;\nconst name = `(?:${nmchar}+)`;\nconst ident = `(?:[-]?${nmstart}${nmchar}*)`;\nconst string1 = `'([^\\\\n\\\\r\\\\f\\\\\\\\']|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;\nconst string2 = `\"([^\\\\n\\\\r\\\\f\\\\\\\\\"]|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*\"`;\nconst lexSelector = createLexer([{\n  name: 'ws',\n  regex: new RegExp(ws)\n}, {\n  name: 'hash',\n  regex: new RegExp(`#${name}`, 'i')\n}, {\n  name: 'ident',\n  regex: new RegExp(ident, 'i')\n}, {\n  name: 'str1',\n  regex: new RegExp(string1, 'i')\n}, {\n  name: 'str2',\n  regex: new RegExp(string2, 'i')\n}, {\n  name: '*'\n}, {\n  name: '.'\n}, {\n  name: ','\n}, {\n  name: '['\n}, {\n  name: ']'\n}, {\n  name: '='\n}, {\n  name: '>'\n}, {\n  name: '|'\n}, {\n  name: '+'\n}, {\n  name: '~'\n}, {\n  name: '^'\n}, {\n  name: '$'\n}]);\nconst lexEscapedString = createLexer([{\n  name: 'unicode',\n  regex: new RegExp(unicode, 'i')\n}, {\n  name: 'escape',\n  regex: new RegExp(escape, 'i')\n}, {\n  name: 'any',\n  regex: new RegExp('[\\\\s\\\\S]', 'i')\n}]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n  return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n  return ss.reduce(sumSpec, [0, 0, 0]);\n}\nconst unicodeEscapedSequence_ = p.token(t => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);\nconst escapedSequence_ = p.token(t => t.name === 'escape' ? t.text.slice(1) : undefined);\nconst anyChar_ = p.token(t => t.name === 'any' ? t.text : undefined);\nconst escapedString_ = p.map(p.many(p.or(unicodeEscapedSequence_, escapedSequence_, anyChar_)), cs => cs.join(''));\nfunction unescape(escapedString) {\n  const lexerResult = lexEscapedString(escapedString);\n  const result = escapedString_({\n    tokens: lexerResult.tokens,\n    options: undefined\n  }, 0);\n  return result.value;\n}\nfunction literal(name) {\n  return p.token(t => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token(t => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n  return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token(t => t.name === 'ident' ? unescape(t.text) : undefined);\nconst hashId_ = p.token(t => t.name === 'hash' ? unescape(t.text.slice(1)) : undefined);\nconst string_ = p.token(t => t.name.startsWith('str') ? unescape(t.text.slice(1, -1)) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({\n  name: name,\n  namespace: ns\n})), p.map(identifier_, name => ({\n  name: name,\n  namespace: null\n})));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), ns => ({\n  type: 'universal',\n  namespace: ns,\n  specificity: [0, 0, 0]\n})), p.map(literal('*'), () => ({\n  type: 'universal',\n  namespace: null,\n  specificity: [0, 0, 0]\n})));\nconst tagSelector_ = p.map(qualifiedName_, ({\n  name,\n  namespace\n}) => ({\n  type: 'tag',\n  name: name,\n  namespace: namespace,\n  specificity: [0, 0, 1]\n}));\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n  type: 'class',\n  name: name,\n  specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, name => ({\n  type: 'id',\n  name: name,\n  specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token(t => {\n  if (t.name === 'ident') {\n    if (t.text === 'i' || t.text === 'I') {\n      return 'i';\n    }\n    if (t.text === 's' || t.text === 'S') {\n      return 's';\n    }\n  }\n  return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, {\n  name,\n  namespace\n}) => ({\n  type: 'attrPresence',\n  name: name,\n  namespace: namespace,\n  specificity: [0, 1, 0]\n}));\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({\n  name,\n  namespace\n}, matcher, {\n  value,\n  modifier\n}) => ({\n  type: 'attrValue',\n  name: name,\n  namespace: namespace,\n  matcher: matcher,\n  value: value,\n  modifier: modifier,\n  specificity: [0, 1, 0]\n})), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), ss => {\n  return {\n    type: 'compound',\n    list: ss,\n    specificity: sumAllSpec(ss.map(s => s.specificity))\n  };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, c => (left, right) => ({\n  type: 'compound',\n  list: [...right.list, {\n    type: 'combinator',\n    combinator: c,\n    left: left,\n    specificity: left.specificity\n  }],\n  specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, s => ({\n  type: 'list',\n  list: [s]\n})), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({\n  type: 'list',\n  list: [...acc.list, next]\n})), complexSelector_);\nfunction parse_(parser, str) {\n  if (!(typeof str === 'string' || str instanceof String)) {\n    throw new Error('Expected a selector string. Actual input is not a string!');\n  }\n  const lexerResult = lexSelector(str);\n  if (!lexerResult.complete) {\n    throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n  }\n  const result = optionallySpaced(parser)({\n    tokens: lexerResult.tokens,\n    options: undefined\n  }, 0);\n  if (!result.matched) {\n    throw new Error(`No match for \"${str}\" input!`);\n  }\n  if (result.position < lexerResult.tokens.length) {\n    const token = lexerResult.tokens[result.position];\n    throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n  }\n  return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n  return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n  return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n  return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'universal':\n      return _serNs(selector.namespace) + '*';\n    case 'tag':\n      return _serNs(selector.namespace) + _serIdent(selector.name);\n    case 'class':\n      return '.' + _serIdent(selector.name);\n    case 'id':\n      return '#' + _serIdent(selector.name);\n    case 'attrPresence':\n      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;\n    case 'attrValue':\n      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}\"${_serStr(selector.value)}\"${selector.modifier ? selector.modifier : ''}]`;\n    case 'combinator':\n      return serialize(selector.left) + selector.combinator;\n    case 'compound':\n      return selector.list.reduce((acc, node) => {\n        if (node.type === 'combinator') {\n          return serialize(node) + acc;\n        } else {\n          return acc + serialize(node);\n        }\n      }, '');\n    case 'list':\n      return selector.list.map(serialize).join(',');\n  }\n}\nfunction _serNs(ns) {\n  return ns || ns === '' ? _serIdent(ns) + '|' : '';\n}\nfunction _codePoint(char) {\n  return `\\\\${char.codePointAt(0).toString(16)} `;\n}\nfunction _serIdent(str) {\n  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\\x00-\\x7F])|(\\x00)|([\\x01-\\x1f]|\\x7f)|([\\s\\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) : d2 ? '-' + _codePoint(d2.slice(1)) : hy ? '\\\\-' : safe ? safe : nl ? '\\ufffd' : ctrl ? _codePoint(ctrl) : '\\\\' + other);\n}\nfunction _serStr(str) {\n  return str.replace(/(\")|(\\\\)|(\\x00)|([\\x01-\\x1f]|\\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\\\\"' : bs ? '\\\\\\\\' : nl ? '\\ufffd' : _codePoint(ctrl));\n}\nfunction normalize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'compound':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n        break;\n      }\n    case 'combinator':\n      {\n        normalize(selector.left);\n        break;\n      }\n    case 'list':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => serialize(a) < serialize(b) ? -1 : 1);\n        break;\n      }\n  }\n  return selector;\n}\nfunction _getSelectorPriority(selector) {\n  switch (selector.type) {\n    case 'universal':\n      return [1];\n    case 'tag':\n      return [1];\n    case 'id':\n      return [2];\n    case 'class':\n      return [3, selector.name];\n    case 'attrPresence':\n      return [4, serialize(selector)];\n    case 'attrValue':\n      return [5, serialize(selector)];\n    case 'combinator':\n      return [15, serialize(selector)];\n  }\n}\nfunction compareSelectors(a, b) {\n  return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n  return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    throw new Error('Arguments must be arrays.');\n  }\n  const shorter = a.length < b.length ? a.length : b.length;\n  for (let i = 0; i < shorter; i++) {\n    if (a[i] === b[i]) {\n      continue;\n    }\n    return a[i] < b[i] ? -1 : 1;\n  }\n  return a.length - b.length;\n}\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };","map":{"version":3,"names":["createLexer","p","ast","Object","freeze","__proto__","ws","nl","nonascii","unicode","escape","nmstart","nmchar","name","ident","string1","string2","lexSelector","regex","RegExp","lexEscapedString","sumSpec","a0","a1","a2","b0","b1","b2","sumAllSpec","ss","reduce","unicodeEscapedSequence_","token","t","String","fromCodePoint","parseInt","text","slice","undefined","escapedSequence_","anyChar_","escapedString_","map","many","or","cs","join","unescape","escapedString","lexerResult","result","tokens","options","value","literal","whitespace_","optionalWhitespace_","option","optionallySpaced","parser","middle","identifier_","hashId_","string_","startsWith","namespace_","left","qualifiedName_","eitherOr","ab","ns","namespace","uniSelector_","type","specificity","tagSelector_","classSelector_","fullstop","idSelector_","attrModifier_","attrValue_","right","v","mod","modifier","attrMatcher_","choice","attrPresenceSelector_","abc","lbr","attrValueSelector_","matcher","attrSelector_","typeSelector_","subclassSelector_","compoundSelector_","flatten","many1","list","s","combinator_","combinatorSeparator_","complexSelector_","leftAssoc2","c","combinator","listSelector_","acc","next","parse_","str","Error","complete","offset","prettyPrintPosition","matched","position","length","len","replace","m","r","padEnd","repeat","parse","parse1","serialize","selector","_serNs","_serIdent","_serStr","node","_codePoint","char","codePointAt","toString","d1","d2","hy","safe","ctrl","other","dq","bs","normalize","forEach","sort","a","b","_compareArrays","_getSelectorPriority","compareSelectors","compareSpecificity","Array","isArray","shorter","i","Ast"],"sources":["D:/shopee_fe/node_modules/parseley/lib/parseley.mjs"],"sourcesContent":["import { createLexer } from 'leac';\nimport * as p from 'peberminta';\n\nvar ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst ws = `(?:[ \\\\t\\\\r\\\\n\\\\f]*)`;\nconst nl = `(?:\\\\n|\\\\r\\\\n|\\\\r|\\\\f)`;\nconst nonascii = `[^\\\\x00-\\\\x7F]`;\nconst unicode = `(?:\\\\\\\\[0-9a-f]{1,6}(?:\\\\r\\\\n|[ \\\\n\\\\r\\\\t\\\\f])?)`;\nconst escape = `(?:\\\\\\\\[^\\\\n\\\\r\\\\f0-9a-f])`;\nconst nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;\nconst nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;\nconst name = `(?:${nmchar}+)`;\nconst ident = `(?:[-]?${nmstart}${nmchar}*)`;\nconst string1 = `'([^\\\\n\\\\r\\\\f\\\\\\\\']|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;\nconst string2 = `\"([^\\\\n\\\\r\\\\f\\\\\\\\\"]|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*\"`;\nconst lexSelector = createLexer([\n    { name: 'ws', regex: new RegExp(ws) },\n    { name: 'hash', regex: new RegExp(`#${name}`, 'i') },\n    { name: 'ident', regex: new RegExp(ident, 'i') },\n    { name: 'str1', regex: new RegExp(string1, 'i') },\n    { name: 'str2', regex: new RegExp(string2, 'i') },\n    { name: '*' },\n    { name: '.' },\n    { name: ',' },\n    { name: '[' },\n    { name: ']' },\n    { name: '=' },\n    { name: '>' },\n    { name: '|' },\n    { name: '+' },\n    { name: '~' },\n    { name: '^' },\n    { name: '$' },\n]);\nconst lexEscapedString = createLexer([\n    { name: 'unicode', regex: new RegExp(unicode, 'i') },\n    { name: 'escape', regex: new RegExp(escape, 'i') },\n    { name: 'any', regex: new RegExp('[\\\\s\\\\S]', 'i') }\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [0, 0, 0]);\n}\nconst unicodeEscapedSequence_ = p.token((t) => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);\nconst escapedSequence_ = p.token((t) => t.name === 'escape' ? t.text.slice(1) : undefined);\nconst anyChar_ = p.token((t) => t.name === 'any' ? t.text : undefined);\nconst escapedString_ = p.map(p.many(p.or(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(''));\nfunction unescape(escapedString) {\n    const lexerResult = lexEscapedString(escapedString);\n    const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);\n    return result.value;\n}\nfunction literal(name) {\n    return p.token((t) => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token((t) => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token((t) => t.name === 'ident' ? unescape(t.text) : undefined);\nconst hashId_ = p.token((t) => t.name === 'hash' ? unescape(t.text.slice(1)) : undefined);\nconst string_ = p.token((t) => t.name.startsWith('str') ? unescape(t.text.slice(1, -1)) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), p.map(identifier_, (name) => ({ name: name, namespace: null })));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), p.map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));\nconst tagSelector_ = p.map(qualifiedName_, ({ name, namespace }) => ({\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n}));\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n    type: 'class',\n    name: name,\n    specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, (name) => ({\n    type: 'id',\n    name: name,\n    specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token((t) => {\n    if (t.name === 'ident') {\n        if (t.text === 'i' || t.text === 'I') {\n            return 'i';\n        }\n        if (t.text === 's' || t.text === 'S') {\n            return 's';\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n}));\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n})), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), (ss) => {\n    return {\n        type: 'compound',\n        list: ss,\n        specificity: sumAllSpec(ss.map(s => s.specificity))\n    };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, (c) => (left, right) => ({\n    type: 'compound',\n    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],\n    specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, (s) => ({ type: 'list', list: [s] })), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);\nfunction parse_(parser, str) {\n    if (!(typeof str === 'string' || str instanceof String)) {\n        throw new Error('Expected a selector string. Actual input is not a string!');\n    }\n    const lexerResult = lexSelector(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` +\n            prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` +\n            prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\n\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'universal':\n            return _serNs(selector.namespace) + '*';\n        case 'tag':\n            return _serNs(selector.namespace) + _serIdent(selector.name);\n        case 'class':\n            return '.' + _serIdent(selector.name);\n        case 'id':\n            return '#' + _serIdent(selector.name);\n        case 'attrPresence':\n            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;\n        case 'attrValue':\n            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}\"${_serStr(selector.value)}\"${(selector.modifier ? selector.modifier : '')}]`;\n        case 'combinator':\n            return serialize(selector.left) + selector.combinator;\n        case 'compound':\n            return selector.list.reduce((acc, node) => {\n                if (node.type === 'combinator') {\n                    return serialize(node) + acc;\n                }\n                else {\n                    return acc + serialize(node);\n                }\n            }, '');\n        case 'list':\n            return selector.list.map(serialize).join(',');\n    }\n}\nfunction _serNs(ns) {\n    return (ns || ns === '')\n        ? _serIdent(ns) + '|'\n        : '';\n}\nfunction _codePoint(char) {\n    return `\\\\${char.codePointAt(0).toString(16)} `;\n}\nfunction _serIdent(str) {\n    return str.replace(\n    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\\x00-\\x7F])|(\\x00)|([\\x01-\\x1f]|\\x7f)|([\\s\\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) :\n        d2 ? '-' + _codePoint(d2.slice(1)) :\n            hy ? '\\\\-' :\n                safe ? safe :\n                    nl ? '\\ufffd' :\n                        ctrl ? _codePoint(ctrl) :\n                            '\\\\' + other);\n}\nfunction _serStr(str) {\n    return str.replace(\n    /(\")|(\\\\)|(\\x00)|([\\x01-\\x1f]|\\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\\\\"' :\n        bs ? '\\\\\\\\' :\n            nl ? '\\ufffd' :\n                _codePoint(ctrl));\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'compound': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n            break;\n        }\n        case 'combinator': {\n            normalize(selector.left);\n            break;\n        }\n        case 'list': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);\n            break;\n        }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch (selector.type) {\n        case 'universal':\n            return [1];\n        case 'tag':\n            return [1];\n        case 'id':\n            return [2];\n        case 'class':\n            return [3, selector.name];\n        case 'attrPresence':\n            return [4, serialize(selector)];\n        case 'attrValue':\n            return [5, serialize(selector)];\n        case 'combinator':\n            return [15, serialize(selector)];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error('Arguments must be arrays.');\n    }\n    const shorter = (a.length < b.length) ? a.length : b.length;\n    for (let i = 0; i < shorter; i++) {\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return (a[i] < b[i]) ? -1 : 1;\n    }\n    return a.length - b.length;\n}\n\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}